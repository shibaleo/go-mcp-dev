---
title: DAY5 作業ログ
aliases:
  - DAY5-work-log
  - work-log-DAY5
tags:
  - MCPist
  - work-log
  - DAY5
  - work
document-type: daily
document-class: log
created: 2026-01-14T00:00:00+09:00
updated: 2026-01-14T00:00:00+09:00
---
# DAY5 作業ログ

## ドキュメント管理情報

| 項目 | 値 |
|------|-----|
| Status | `current` |
| Version | v1.0 (DAY5) |
| Note | DAY5作業ログ |

---

## 目的

DAY4で作成した仕様書の詳細化を行う。

---

## 作業記録

### 2026-01-14

#### 初期セットアップ

- [x] DAY4からファイルをコピー
- [x] フォルダ構成を整理
- [x] 各仕様書のメタデータを更新

#### 詳細化作業

- [ ] spec-sys: システム仕様の詳細化
- [ ] spec-dsn: 設計仕様の詳細化
- [ ] spec-inf: インフラ仕様の詳細化
- [ ] spec-ops: 運用仕様の詳細化
- [ ] spec-tst: テスト仕様の詳細化
- [ ] spec-mnl: マニュアル仕様の詳細化

---

## メモ

### ブレインストーミング（2026-01-14）

**現状の課題:**
- DAY0: コンセプトペーパー書いていない
- DAY0: exploratory prototype (今の実装)を作ったけど、ドキュメントなし
- 今の実装でどうしていけると思ったのか記入なし
- DAY5 で仕様を詳細化した後、どのように作業を進めるか

**検討した案:**
- 案1: 極限まで詳細化し、あと戻ししない前提で進める
- 案2: 開発プロマネの立場で開発計画を策定（案1はプロマネがいない前提で計画を進めているという状態）
- 案3: 詳細仕様とペルソナを突き合わせ、バージョン2を構想する
- 案4: テスト仕様詳細化後、テストから実装し始める（テスト駆動開発）
- 案5: ops, mnlの先、契約・受注・その他企業において必要な手続きに関する計画を立てる。契約は自分自身と行い、契約書も残す
- 案6: システムにおける不変部分（仕様の詳細化で変わらない部分）を特定し、再検討。仮に問題があれば、仕様全体を変更するか、v2で対応

### Claudeのまとめ

**案の分類:**

| 案 | 方向性 | リスク | 価値 |
|----|--------|--------|------|
| 案1 | 詳細化→実装 | 手戻りコスト大 | シンプル |
| 案2 | プロマネ視点導入 | 計画過剰 | ガバナンス |
| 案3 | v2構想 | スコープ拡大 | 長期視点 |
| 案4 | TDD | テスト先行の負荷 | 品質担保 |
| 案5 | 契約・手続き | 形式的 | 完全性 |
| 案6 | 不変部分特定 | 分析時間 | 手戻り防止 |

**提案した優先度:**

優先度高（今日やるべき）:
1. 案6（不変部分の特定）- 仕様詳細化前にやるべき。変わらないコア部分を明確にすることで、手戻りを防ぐ
2. DAY0の補完 - プロトタイプの判断根拠を記録（今やらないと忘れる）

優先度中:
3. 案2（開発計画）- 詳細化の「深さ」を決めるため
4. 案4（TDD）- spec-tstの詳細化と連動

優先度低（後でよい）:
5. 案1, 案3, 案5

---

### 開発プロセス方針の決定（2026-01-14）

**提案: クライアント視点の比例的進捗管理**

従来の開発（ウォーターフォール/アジャイル）は開発者視点の進捗管理に重点を置いていた。
本プロジェクトでは「クライアント視点の比例的進捗管理」を採用する。

**スプリントの流れ:**

```
[Forward Pass]
ペルソナ分析            要件定義       コア特定              クライアントチェック
ユーザーストーリー --->  仕様書   ---> プロトタイプ作成  --->  評価
受け入れ条件            詳細化         e2eテスト実行            │
                                                              |
                                                              |
                                                              ▼
[Backpropagation - 逆順で検証]
0. クライアントの不満・課題・追加要求の特定
1. e2e合格なのになぜ不満があったのか
2. prototypeで確認したのになぜ問題があったのか
3. コア機能を特定したのになぜ問題があったのか
4. 仕様・要求・ユーザー受け入れ条件で何を見過ごしていたのか
5. ペルソナ分析・ユーザーストーリーで何を見過ごしていたのか
6. 開発全体の工程や進捗把握に問題がなかったのか
                                     │
                                     ▼
                     [1スプリント完了]
```

**価値:**
- クライアント視点で比例的に進捗を把握できる
- 問題の根本原因を工程単位で特定できる
- 構造化されたフィードバックにより学習効果が高い

**クライアントチェックの実施者:**
- 使用者、管理者、開発責任者、実装者、提案者のすべての役を一人で担当
- 各役になりきって別人格として評価を行う

**成果物:**
- sprint-retrospective（スプリント振り返りログ）を新規フォーマットとして作成

---

## 次のアクション

### 今日やること

1. [x] sprint-retrospectiveフォーマットの作成
2. [x] コア部分（不変部分）の特定
3. [x] コア要件の選定（96件から最初のスプリント対象5〜10件を選ぶ）→ P0として7件選定
4. [x] 要件の優先度付け（P0コア/P1重要/P2後回し）→ P0選定完了、P1/P2は後続スプリントで
5. [x] LLMベンダ依存33件のスコープ外確認 → 29件はOFS対応済み、4件は部分対応可
6. [x] DAY0の補完（プロトタイプ判断根拠の記録）→ [concept-paper.md](../DAY0/concept-paper.md) 作成

### 課題: トレーサビリティの欠如と解決策

**問題認識:**
- REQ-SPC対応がないのは、各段階でギャップ分析ができていないため
- 詳細化フェーズ(DTL)と仕様書作成フェーズ(SPC)は分けるべき
- SPC-DTLのギャップ分析も必要
- 各段階で細かくID化することで、バックプロパゲーションを容易にする

**決定: ID体系の整備**

| フェーズ | ID | 説明 | ギャップ分析 |
|----------|-----|------|-------------|
| ペルソナ | PSN-xxx | ペルソナ定義 | - |
| ユーザーストーリー | UST-xxx | ユーザーストーリー | PSN ↔ UST |
| 受け入れ条件 | ACC-xxx | 受け入れ条件 | UST ↔ ACC |
| 要件 | REQ-xxx | 要件 | ACC ↔ REQ |
| 仕様書 | SPC-xxx | 仕様項目 | REQ ↔ SPC |
| 詳細化 | DTL-xxx | 詳細設計項目 | SPC ↔ DTL |
| 実装 | IMP-xxx | 実装単位 | DTL ↔ IMP |
| テスト | TST-xxx | テストケース | IMP ↔ TST |
| E2E | E2E-xxx | E2Eシナリオ | ACC ↔ E2E |

**ギャップ分析の連鎖:**

```
PSN ─gap─> UST ─gap─> ACC ─gap─> REQ ─gap─> SPC ─gap─> DTL ─gap─> IMP ─gap─> TST
                       │                                                      │
                       └──────────────────── gap (E2E) ────────────────────────┘
```

**バックプロパゲーション時の追跡例:**

```
クライアント不満 ISS-001
    ↓ どのE2Eが関連？
E2E-005 不合格
    ↓ どのACCが未充足？
ACC-023
    ↓ どのUSTが関連？
UST-008
    ↓ どのPSNが関連？
PSN-002
    ↓ ペルソナ定義の問題？ストーリー設定の問題？
```

**現状との対応（要変換）:**

| 現在のID | 新ID | 備考 |
|----------|------|------|
| PSN-1-ACC-02 | PSN-001 + UST-xxx + ACC-xxx | 分離が必要 |
| REQ-xxx | REQ-xxx | 維持（既存96件） |

**価値:**
- 理想論で終わらせないための必要コスト
- ペルソナ分析自体の問題点を洗い出せる
- ユーザーストーリー設定作業の問題点を洗い出せる
- バックプロパゲーションが具体的に実行可能になる

---

### SPRINT-000 対象要件選定（2026-01-14）

**選定基準:**
- P0（アーキテクチャ根幹）: CORE-001〜004に直接対応する要件
- 自前実装 + 外部規格依存のみ（LLMベンダ依存33件は除外）
- セキュリティ関連を優先

**P0選定要件（7件）:**

| REQ-ID | 項目 | 対応CORE | 分類 |
|--------|------|----------|------|
| REQ-001 | 個人用アカウントは他アカウントと分離 | CORE-001, CORE-007 | 自前実装 |
| REQ-023 | 他人のデータ侵害につながる設計は避ける | CORE-001, CORE-005 | 自前実装 |
| REQ-024 | 権限・データ境界が明確に分離 | CORE-001, CORE-005 | 自前実装 |
| REQ-025 | デフォルトが安全側の実装 | CORE-001, CORE-005 | 自前実装 |
| REQ-039 | 必要最低限の情報だけがコンテキストに含まれる | CORE-002, CORE-003, CORE-006 | 外部規格 |
| REQ-096 | MCPサーバーの単一エンドポイント提供 | CORE-004 | 自前実装 |
| REQ-013 | ユーザー操作なしで継続実行（自動リフレッシュ） | CORE-007 | 外部規格 |

**CORE↔REQ対応マトリックス:**

| CORE | 対応REQ |
|------|---------|
| CORE-001 (認証3層) | REQ-001, REQ-023, REQ-024, REQ-025 |
| CORE-002 (モジュール中心) | REQ-039 |
| CORE-003 (メタツール) | REQ-039 |
| CORE-004 (サーバー側認証) | REQ-096 |
| CORE-005 (RLS非依存) | REQ-023, REQ-024, REQ-025 |
| CORE-006 (Tool Sieve) | REQ-039 |
| CORE-007 (Token Broker) | REQ-001, REQ-013 |

---

### LLMベンダ依存要件の確認（2026-01-14）

**確認結果:**

req-list.mdの「LLMベンダ依存（33項目）」のうち：
- 29件: req-ofs.md（OFS-001〜OFS-006）で整理済み
- 4件: 部分対応可能（MCPサーバー側で一部対応）

**部分対応可能な4件:**

| REQ-ID | 項目 | MCPサーバー側対応 |
|--------|------|-------------------|
| REQ-040 | タスク実行時に不要な情報参照が発生しない | CORE-003メタツールで対応 |
| REQ-041 | アカウント切り替え操作は最小限 | 管理UIで対応可 |
| REQ-042 | 複数UI操作を意識せずタスク完了 | 単一エンドポイントで対応 |
| REQ-043 | 必要なツールだけをLLMが呼び出す | Tool Sieveで権限制御 |

**結論:** LLMベンダ依存33件はスコープ外として整理完了。部分対応可能な4件はCORE機能で対応済み。

---

### コア機能特定（2026-01-14）

コア機能（不変部分）を特定し、別ドキュメントとして切り出し。

**評価基準:**
- **強固なコア（2つ以上の独立した理由）**: 変更しづらい
- **暫定的コア（1つの理由のみ）**: その理由が変われば変更可能

**成果物:** [dtl-core.md](dtl-core.md)

**サマリー（12件）:**

**強固なコア（8件）:**

| ID | コア機能 | 独立した理由の数 |
|----|----------|-----------------|
| COR-001 | メタツール方式 | 3（Context Rot、セキュリティ、MCP仕様制約回避） |
| COR-003 | サーバー側認証設計 | 3（クライアント非依存、ポータビリティ、Electron対応） |
| COR-004 | 決定論的オーケストレーター | 3（品質管理、コスト、障害点削減） |
| COR-005 | RLS非依存認可 | 2（ポータビリティ、多層防御） |
| COR-006 | Next.js採用 | 3（$0制約、SPA要件、Electron対応） |
| COR-007 | Go採用 | 5（$0制約、SSE直接実装、差別化、非同期適性、サーバー計算） |
| COR-008 | TOON形式 | 2（Context Rot対策、LLMベンダーの対処動機欠如） |
| COR-009 | モジュールCLI実装 | 2（レジストリ構造平準化、人間/LLM実行等価性） |

**除外されたコア候補:**
- シングルテナント設計（旧COR-001）: MCPistの存在意義が進化（パワーユーザー向け→社内AIインフラのデザインパターン提示）

**暫定的コア（4件）:**

| ID | コア機能 | 理由（1つのみ） |
|----|----------|----------------|
| COR-101 | $0/月コスト制約 | 開発者の意向 |
| COR-102 | Koyeb選択 | $0制約 |
| COR-103 | Vercel選択 | $0制約 |
| COR-104 | コールドスタート対策 | Koyeb Free Tier |

**重要な洞察:**
- $0制約（COR-101）は「制約」であって「コア機能」ではない
- Next.js（COR-006）とGo（COR-007）は$0制約以外にも理由があるため、$0制約が変わっても維持される
- Vercel/Koyeb選択は$0制約のみが理由のため、制約が変われば変更可能

---

### スプリント計画（2026-01-14決定）

**現スプリント（SPRINT-000）の方針:**

1. 詳細化後にDTL, IMP, TST, E2Eの計画書を作成
2. クライアントチェックを実施し、ISSを洗い出す
3. 現在SPC, DTLが爆発し始めているため、**コア機能特定を優先実行**

**次スプリント（SPRINT-001）の方針:**

- 前回のID（PSN, UST, ACC, REQ, SPC, DTL, IMP, TST, E2E, ISS）を整理
- 新たにForward Passを開始

### 今後やること

- [ ] ID体系に基づくドキュメント再構成計画
- [ ] 開発プロセス方針に基づくスプリント計画の策定
- [ ] SPRINT-000完了（DTL/IMP/TST/E2E計画 → クライアントチェック → ISS洗い出し）
- [ ] SPRINT-001開始（ID整理 → 新Forward Pass）

# ADR-002: マルチテナントからシングルテナントへの設計変更

## ステータス

**Accepted** (2025-01-11)

## コンテキスト

MCPistは当初、**Pooled Multi-Tenant型**として設計を検討していた。複数ユーザーが単一のMCPサーバーを共有し、RBAC + RLSで分離する構造である。

```
【当初の想定: Pooled Multi-Tenant】

MCPistサーバー（共有）
  ├─ ユーザーA
  │    └─ Notion, GitHub, Jira...
  ├─ ユーザーB
  │    └─ Notion, Slack...
  └─ ユーザーC
       └─ GitHub, Confluence...

→ 複数ユーザーのトークンを集約管理
→ スケールメリット、インフラ効率化
```

この設計はZapier/Workato的な「統合プラットフォーム」モデルに近い。

## 決定

MCPistは**シングルテナント・シングルユーザー・マルチアカウント型**を採用する。

```
【採用した設計: シングルテナント・シングルユーザー・マルチアカウント】

テナント: 自分（1）
  └─ ユーザー: 自分（1）
       └─ アカウント1（個人用Notion, Google Calendar...）
       └─ アカウント2（仕事用GitHub, Outlook...）
       └─ アカウント3（副業用Jira，Confluence...）

→ 1サーバーで複数アカウントを管理 = インフラ節約
→ Trust Boundary維持（全部自分の権限）
```

## 理由

### 1. Token Exchangerとの整合性

MCPistはMCP認証仕様の問題提起として「Token Exchanger」パターンをはじめに検討した。

Token Exchangerの仕組みは，ユーザー資産である外部サービスへのシークレットをMCPサーバーに見せることなく，外部サービスへのアクセスのみに使用する仕組み: 
1. MCP サーバー接続時にOAuth2.0ログイン
2. MCPサーバーアクセス時にユーザJWTで検証
3. ユーザーJWTを使ってToken Exchangerへアクセス
4. Token Exchangerがユーザに紐づく外部サービスのシークレットをMCPサーバーに渡す
5. MCPサーバーがシークレットを使って，ユーザーの外部サービスへのアクセスを代行する

しかし，

> Token Exchangerは「ユーザーの外部サービス権限を代理行使できる」構造を作り、Trust Boundaryを崩壊させる。これはOAuthが20年かけて避けてきた設計である。

Pooled Multi-Tenant型は、Token Exchangerを採用せずに以下の構造を採用することになる：

- 他人のトークンを預かる
- MCP Serverが全ユーザー全サービスの権限を代理行使
- 侵害時に全ユーザー全サービスが即死

**MCPistはSaaSサービスを志向しないため，他人のユーザー情報を保持しない。**
そのためTokenExchangerを仕組みとして持つことが許容される．

### 2. Trust Boundaryの維持

シングルテナント・シングルユーザー構造では：

- 預かるトークンは全て**自分自身の権限**
- サーバー侵害時の影響範囲 = 自分のアカウントのみ
- 「誰が操作したか」は常に明確（自分）

Trust Boundaryが維持され、責任の所在が明確になる。

### 3. MCPistの本質的価値との整合性

MCPistの本質は「Personal Context Management」である。

**Context Rotは業界で既に認識されている問題である。** Cursor（40ツール制限）、GitHub Copilot（128ツール制限）など、各社が対応策を講じている。しかし、これらは**ベンダー側の制限**であり、個人ユーザーが自分のコンテキストを最適化する手段は提供されていない。

MCPistは、**Context Rotを「個人が解決すべき課題」として位置づける**：

- **認知資源の管理**：自分のコンテキストを自分で最適化
- **注意資源の管理**：LLMが何に注意を向けるかを自分で制御
- **PKMの延長**：個人知識システムのLLM時代への適用

これらは本質的に**個人的**な営みであり、マルチテナント化する動機がない。ベンダーが解決すべき問題ではなく、個人が自ら管理すべき問題として捉え直したからこそ、シングルテナント設計が必然となる。

### 4. 「マルチアカウント」の位置づけ

MCPistの「マルチアカウント」機能は、マルチテナントの代替ではない。

**目的**: 従来のシングルアカウントMCPサーバーを複数運用する煩雑さ・インフラオーバーヘッドを避けること

```
【従来】
Notion用MCPサーバー + GitHub用MCPサーバー + Jira用MCPサーバー
→ 3つのインスタンス運用、3つの認証設定、3つの監視...

【MCPist】
MCPistサーバー（1つ）
  └─ Notion + GitHub + Jira
→ 1つのインスタンスで統合管理
```

これは「節約手段」であり、設計思想ではない。

## 構造比較

| 構造 | テナント | ユーザー | アカウント | 例 |
|------|---------|---------|-----------|-----|
| **従来のMCP** | シングル | シングル | シングル | 1サービス専用MCPサーバー |
| **MCPist** | シングル | シングル | **マルチ** | 複数サービス統合MCPサーバー |
| **Pooled Multi-Tenant** | マルチ | マルチ | マルチ | Zapier的プラットフォーム |

## 影響

### 採用しないもの

- マルチユーザー認証（RBAC、ユーザー管理UI）
- 固定シークレット認証（Bearer token）
- 環境変数による認証情報管理

ただし，以下はアカウントを分離する目的で手段として採用する．
- アカウント分離（RLS、ネームスペース）
- アカウント間のデータ共有機能
- 課金・クォータ管理（アカウント単位）

### 採用するもの

- セルフホスト前提のデプロイモデル
- オブザーバビリティ（自分のための監視）
---
## 代替案

### 案A: Pooled Multi-Tenant（却下）

**理由**: Token Exchanger批判との自己矛盾。Trust Boundary崩壊リスク。

### 案B: Dedicated Instance per User（却下）

**理由**: MCPistの価値提案と同じ。ただしMCPistはこれを「各ユーザーが自分でデプロイする」形で実現する。MCPist自体がマルチテナントになる必要はない。

### 案C: シングルテナント・シングルユーザー・マルチアカウント（採用）

**理由**: Trust Boundary維持、PKM思想との整合性、Token Exchanger批判との一貫性。

## 結論

MCPistは**万人向けのプラットフォーム**ではなく、**特定の人のための個人ツール**である。

> A quiet game changer for people who already know too much.

この位置づけにおいて、マルチテナント化は価値を生まない。むしろ、MCPistが批判してきた構造を自ら採用することになり、設計の一貫性を損なう。

シングルテナント・シングルユーザー・マルチアカウント構造は、MCPistの思想的立場を実装に反映した必然的な選択である。

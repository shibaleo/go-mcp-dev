# go-mcp-dev 認証アーキテクチャ: Vault + Auth 設計

## 概要

本ドキュメントでは、go-mcp-devプロジェクトにおける**認証・シークレット管理アーキテクチャ**を定義する。Supabase Vaultで外部サービスのユーザトークン(多くはOAuth2.0 リフレッシュトークン)を管理し、Supabase AuthでMCPサーバーへのアクセスを認証(OAuth2.1)する。

Supabase Vault+Edge FunctionはMCPist設計におけるToken Exchangerに相当する．
ユーザーは外部サービスのOAuth認証アプリケーションを自ら作成し，管理UIによってVaultに登録する．
Vault内のシークレットは，MCPサーバーが関数を呼び出した際に呼びされ，外部サービスへのアクセス権を与える

## 設計原則

- **完全ステートレス (RESTful)**: サーバーは状態を持たない。毎リクエストでVaultから取得
- **関心の分離**: 認証層（Auth）とシークレット管理層（Vault）を明確に分離
- **コスト最適化**: Supabase無料枠で運用
- **スケーラビリティ**: ステートレスなので自由にスケールアウト可能

---

## アーキテクチャ図

```
┌─────────────────────────────────────────────────────────────────────┐
│                        Claude / LLM Client                          │
└─────────────────────────────────────┬───────────────────────────────┘
                                  │ Bearer Token (Supabase Auth JWT)
                                  ▼
┌─────────────────────────────────────────────────────────────────────┐
│                      Go MCP Server (Koyeb Nano)                     │
│                      *** 完全ステートレス ***                        │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │  Auth Middleware (JWT検証)                                    │  │
│  │  → Supabase Auth で発行されたJWTを検証                         │  │
│  │  → userID抽出                                                 │  │
│  └───────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │  Module Registry                                              │  │
│  │  └─ notion / github / jira / confluence / google_calendar     │  │
│  └───────────────────────────────────────────────────────────────┘  │
└───┬─────────────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────────────────┐
│                           Supabase                                  │
│  ┌─────────────────────────────┐  ┌─────────────────────────────┐  │
│  │        Supabase Auth        │  │       Supabase Vault        │  │
│  │  ・JWT発行・検証            │  │  ・OAuthトークン暗号化保存   │  │
│  │  ・ユーザー管理             │  │  ・リフレッシュトークン管理  │  │
│  │  ・セッション管理           │  │  ・自動復号                 │  │
│  └─────────────────────────────┘  └─────────────────────────────┘  │
│                                          │                          │
│                                          ▼                          │
│                              ┌─────────────────────┐                │
│                              │  OAuth認可サーバー   │                │
│                              │  (Google, GitHub等)  │                │
│                              └─────────────────────┘                │
└─────────────────────────────────────────────────────────────────────┘
```

---

## コンポーネント詳細

### 1. Supabase Auth（MCPサーバー認証）

#### 役割

- **MCPサーバーへのアクセス認証**: LLMクライアントからのリクエストを認証
- **JWT発行**: ユーザー認証後にJWTを発行
- **ユーザー管理**: ユーザー登録、ログイン、セッション管理

#### 認証フロー

```
1. ユーザーがSupabase Authでログイン（Email/OAuth）
2. Supabase AuthがJWTを発行
3. LLMクライアントがJWTをBearerトークンとしてMCPサーバーに送信
4. MCPサーバーのmiddlewareがJWTを検証
5. 検証成功 → user_accountIDを抽出してリクエスト処理
```

---

### 2. Supabase Vault（OAuthトークン管理）

#### 役割

- **OAuthトークンの暗号化保存**: 外部サービス（Google, GitHub, Notion等）のアクセストークン・リフレッシュトークンを暗号化して保存
- **OAuth認可サーバーとのやり取り**: トークンリフレッシュ処理
- **自動復号**: 必要時に自動で復号して返却

#### 暗号化仕様

| 項目 | 値 |
|------|-----|
| アルゴリズム | AES-256-GCM (認証付き暗号化) |
| キー管理 | Supabaseバックエンドで自動管理 |
| 改ざん検知 | 認証タグによる整合性検証 |

```

#### OAuthトークン保存・取得フロー

```
【トークン保存（OAuth認可後）】
1. ユーザーが外部サービス（Google等）でOAuth認可
2. 認可サーバーがアクセストークン + リフレッシュトークンを返却
3. MCPサーバーがVaultにトークンを暗号化保存
   - vault.create_secret() でアクセストークン保存
   - vault.create_secret() でリフレッシュトークン保存
   - user_oauth_tokens テーブルに参照を記録

【トークン取得（ツール実行時）】
1. MCPサーバーがuser_oauth_tokensからsecret_idを取得
2. vault.decrypted_secrets からトークンを復号取得
3. token_expires_at を確認
4. 期限切れの場合:
   - リフレッシュトークンで認可サーバーに新トークンをリクエスト
   - 新トークンをVaultに保存（古いトークンは削除）
1. 有効なアクセストークンでAPIコール


### Vault 呼び出しのためのEdge Function
- Vault 呼び出しの際にaccess tokenが失効していた場合ユーザートークンをリフレッシュしてから返却する．
- トークンリフレッシュはEdge Function側で持つ．MCPサーバ(ユーザー情報使用)側では管理しない．
---

## 完全ステートレス設計

### 設計思想

RESTの原則に従い、**サーバーは一切の状態を持たない**。毎リクエストでVaultからシークレットを取得する。

### なぜステートレスか

| 方式 | 状態 | スケール | 複雑さ | 遅延 |
|------|------|----------|--------|------|
| メモリキャッシュ | サーバーに持つ | ❌ 1台のみ | 中 | 初回700ms、2回目0ms |
| Redis | Redisに持つ | ✅ 複数台OK | 高 | 初回700ms、2回目~5ms |
| **完全ステートレス** | **なし** | **✅ 複数台OK** | **低** | **毎回700ms** |

### レイテンシ分析

| 処理                     | 時間     | 備考             |
| ---------------------- | ------ | -------------- |
| **Vault全シークレット取得（並列）** | ~700ms | リフレッシュトークン更新含む |


### リクエストフロー

```
リクエスト受信 (Bearer JWT)
    │
    ▼
Auth Middleware: JWT検証 → user_accountID抽出
    │
    ▼
Vault Edge Function: OAuthトークン取得（リトライ付き）~700ms
    │         ※期限切れの場合は自動リフレッシュ
    ▼
ツール実行（userのトークンで外部API呼出）
    │
    ▼
レスポンス返却
（状態は何も残らない）
```

### マルチアカウント対応

ステートレスなので自然にマルチアカウント対応。

| リクエスト      | userID | Vaultから取得   | 結果   |
| ---------- | ------ | ----------- | ---- |
| Account A  | a123   | AのOAuthトークン | Aの結果 |
| Account  B | b456   | BのOAuthトークン | Bの結果 |
| Account  A | a123   | AのOAuthトークン | Aの結果 |

毎回userIDでVaultを引くので、状態を持つ必要がない。

---

## Vault堅牢リトライ実装

### 設計方針

Vaultは認証基盤。ここが失敗すると全ツールが使えない。**最も堅牢なリトライを実装する。**

### リトライ戦略

| 項目       | 値                            |
| -------- | ---------------------------- |
| 最大リトライ回数 | 2回                           |
| 初期遅延     | 100ms                        |
| バックオフ    | Exponential (100ms → 200ms ) |
| 最大遅延     | 200ms                        |
| ジッター     | ±20%（同時リトライの衝突回避）            |
| タイムアウト   | 2s（全リトライ含む）                  |

### リトライ対象エラー

| エラー | リトライ | 理由 |
|--------|----------|------|
| 429 Too Many Requests | ✅ | Rate limit、待てば解消 |
| 500 Internal Server Error | ✅ | 一時的障害 |
| 502 Bad Gateway | ✅ | 一時的障害 |
| 503 Service Unavailable | ✅ | 一時的障害 |
| 504 Gateway Timeout | ✅ | 一時的障害 |
| Connection error | ✅ | ネットワーク障害 |
| Timeout | ✅ | 一時的遅延 |
| 401 Unauthorized | ❌ | 認証エラー、リトライ無意味 |
| 403 Forbidden | ❌ | 権限エラー、リトライ無意味 |
| 404 Not Found | ❌ | リソースなし、リトライ無意味 |

---

## 実装モジュール構成

```
internal/
├── auth/               # Supabase Auth ミドルウェア
│   └── middleware.go   # JWT検証、userID抽出
├── vault/              # Supabase Vault クライアント
│   ├── client.go       # 堅牢リトライ付きEdge Function呼び出し
│   └── retry.go        # リトライロジック
└── modules/
    ├── notion/
    ├── github/
    ├── jira/
    ├── confluence/
    └── google_calendar/

supabase/functions/
└── vault-token/        # OAuthトークン管理Edge Function
    └── index.ts        # トークン取得・リフレッシュ処理
```

---

## セキュリティ考慮事項

1. **シークレット露出防止**
   - Supabaseのステートメントログを無効化
   - Go側でシークレットをログ出力しない
   - ステートレス設計でメモリにも残らない

2. **通信暗号化**
   - 全接続でTLS 1.3使用
   - Supabase接続: HTTPS必須

3. **アクセス制御**
   - Supabase Service Role Keyは厳重管理
   - RLSでマルチアカウント分離
   - JWTの有効期限を適切に設定

4. **OAuthトークン管理**
   - リフレッシュトークンは必ず暗号化保存
   - トークン期限切れ前に自動リフレッシュ
   - 認可取り消し時はVaultから即削除

---

## サービス構成

| サービス | 用途 | 無料枠 |
|----------|------|--------|
| **Supabase Auth** | MCPサーバー認証、JWT発行 | 50K MAU |
| **Supabase Vault** | OAuthトークン暗号化保存 | 含む |
| **Koyeb** | MCP Server | Nano (256MB) |

### 月額コスト: $0

---

## Auth と Vault の責務分離

### Supabase Auth（GoTrue）

- **役割**: ユーザーの本人確認・セッション管理
- **扱うもの**: パスワード（ハッシュ）、OAuth ログイン、JWT
- **扱わないもの**: 外部サービス用のトークンや秘密

### Supabase Vault

- **役割**: ユーザーやアプリが預ける「秘密値」の安全な保管
- **実体**: Postgres 拡張＋暗号化
- **用途**: 寿命や用途に関係なく「秘密」を保存する場所

**両者は上下関係ではなく責務分離。**

---

## Vault に入れるべき「カギ」の判断基準

基準は1つだけ：

> **失うと、ユーザーの再操作（再認可・再発行）なしに復旧できないか？**
>
> - YES → Vault
> - NO → キャッシュ / 一時保存

この基準で判断すると：

| トークン種別 | Vault保存 | 理由 |
|-------------|-----------|------|
| refresh_token | ✅ | 再認可が必要 |
| 長命 access_token | ✅ | 再発行が困難 |
| client_secret（ユーザー資産） | ✅ | 再発行が困難 |
| API key / private key | ✅ | 再発行が必要 |
| 短命で再取得可能な access_token | ❌ | refresh_tokenで再取得可能 |

※ 寿命・OAuth 仕様名は関係ない

---

## 実践的な現実解（OAuth 周り）

provider ごとの仕様差・癖は現実に存在する。よって理論的分離（refresh だけ Vault）は常に正解ではない。

**現実解:**

> access_token / refresh_token / scope / client_id / client_secret を
> ユーザー単位の **1 JSON として Vault に保存**

これにより：

- provider 依存を最小化
- 失敗モードを明確化
- 実装と運用を単純化

する、**安全側の設計**。

---

## 運用上の注意点

1. **Vault key は provider + user で分ける**
2. **JSON に version / expires_at を持たせる**
3. **refresh 処理は 1 箇所に集約**（競合回避）

---

## シークレット保存場所の整理

| 種別 | 保存先 | 説明 |
|------|--------|------|
| ユーザー認証 | Supabase Auth (GoTrue) | ログイン・セッション管理・JWT発行 |
| ユーザーの外部サービス認証情報（全て） | Vault | OAuthトークン、APIキー等（暗号化保存） |
| MCPistインフラ設定 | 環境変数 | SUPABASE_URL, SUPABASE_KEY 等 |




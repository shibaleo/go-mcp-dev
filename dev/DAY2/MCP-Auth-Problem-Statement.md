# MCP認証仕様の課題と解決提案

## 概要

本文書は、MCP（Model Context Protocol）の認証仕様が抱える構造的課題を整理し、MCPエコシステムの健全な成長に必要な解決策を提案する。

---

## 現状のMCP認証仕様

### 想定モデル

MCP公式認証仕様（2025年11月）は以下の役割分離を前提としている:

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  MCP開発者      │     │  Auth管理者     │     │  エンドユーザー │
│                 │     │                 │     │                 │
│  ツール実装     │     │  IdP運用        │     │  サービス利用   │
│  MCP Server構築 │     │  ポリシー管理   │     │  OAuth認可      │
└─────────────────┘     └─────────────────┘     └─────────────────┘
       ↑                       ↑                       ↑
   別の人/組織             別の人/組織             別の人
```

### 認証フロー

MCP仕様では、認証はクライアント側の責任として定義されている:

1. MCPクライアントがOAuthフローを開始
2. Authorization Serverがトークンを発行
3. クライアントがトークンを保持・管理
4. MCPサーバーはトークンを検証のみ（保持しない）

### エンタープライズ向け機能

- **Cross App Access (XAA)**: Enterprise IdPを経由したトークン交換
- **ID-JAG**: IdPが発行する一時的なアサーショントークン
- **Resource Indicators (RFC 8707)**: トークンの意図された受信者を明示

---

## 課題

### 1. 役割分離の前提が成立しないケース

MCP仕様は「MCP開発者」と「Auth管理者」が別の人/組織であることを前提としている。

```
【エンタープライズ】
MCP開発者: 社内開発チーム or ベンダー
Auth管理者: 情シス部門（Okta, Azure AD等を運用）
→ 役割分離が自然に成立

【個人/小規模開発者】
MCP開発者: 自分
Auth管理者: 自分（しかしIdPを持っていない）
→ 役割分離が成立しない
```

### 2. Enterprise IdPへの依存

XAAやID-JAGは、Enterprise IdP（Okta, Azure AD, Ping Identity等）の存在を前提としている。

| 対象 | IdP保有 | MCP認証仕様の対応 |
|------|---------|------------------|
| 大企業 | ✅ 保有 | ✅ 対応済み |
| 中小企業 | △ 一部保有 | △ 部分的に対応 |
| 個人開発者 | ❌ 未保有 | ❌ **未対応** |
| スタートアップ | ❌ 多くは未保有 | ❌ **未対応** |

### 3. 外部サービストークンの管理責任

MCP仕様では、外部サービス（Notion, GitHub等）へのトークンをクライアントが保持することを想定している。

**問題点**:
- MCPクライアント（Claude, Cursor等）が各外部サービスのOAuthを実装する必要
- ユーザーが複数サービスのトークンをクライアントに預ける形になる
- MCPサーバーが複数の外部サービスを統合する場合、クライアントが全サービスのトークンを持つ？

```
【MCP仕様の想定】
ユーザー → 外部サービスA のトークン取得 → クライアントに保存
        → 外部サービスB のトークン取得 → クライアントに保存
        → 外部サービスC のトークン取得 → クライアントに保存
        → MCPサーバーにアクセス時、各トークンを提示

【現実的な課題】
- クライアントがすべてのOAuthプロバイダーを実装？
- トークン漏洩リスクの集中
- 統合MCPサーバー（複数サービスを束ねる）との相性が悪い
```

### 4. 参入障壁の高さ

個人開発者がMCPサーバーを構築する場合の現実:

```
1. 外部サービスA の OAuth アプリ登録
2. 外部サービスB の OAuth アプリ登録
3. 外部サービスC の OAuth アプリ登録
4. ... (使いたいサービス分だけ繰り返し)
5. トークン暗号化保存の実装
6. リフレッシュ処理の実装
7. セキュリティ監査対応
8. やっとツール開発開始
```

**結果**: 参入障壁が高すぎ、MCPエコシステムの成長が阻害される

### 5. エコシステムの分断リスク

現状のまま進むと:

- エンタープライズ: MCP標準認証を採用
- 個人/小規模: 独自実装 or MCP不採用

→ **エコシステムが分断され、MCPの普及が限定的になる**

---

## 解決提案: Token Exchanger パターン

### 基本概念

認証インフラを「Token Exchanger Provider」として切り出し、MCP開発者はツール開発のみに集中できるようにする。

```
┌─────────────────────────────────────────────────────────────────┐
│                 Token Exchanger Provider                         │
│          (プラットフォーム事業者が運営)                          │
│                                                                  │
│  責務:                                                           │
│  - 各外部サービスとのOAuth連携・契約                             │
│  - ユーザートークンの安全な保管・リフレッシュ                    │
│  - Token Exchange API の提供                                     │
│  - セキュリティ監査・コンプライアンス対応                        │
└──────────────────────────────────┬──────────────────────────────┘
                                   │
                                   │ Token Exchange API
                                   │ (userID + provider → access_token)
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────┐
│                    MCP Server (開発者)                           │
│                                                                  │
│  責務:                                                           │
│  - ツールロジックの実装のみ                                      │
│  - OAuth実装不要                                                 │
│  - シークレット保持不要                                          │
└─────────────────────────────────────────────────────────────────┘
```

### Token Exchange API 仕様案

```
POST /token/exchange
Authorization: Bearer <mcp_server_credential>
Content-Type: application/json

{
  "user_id": "user-123",
  "provider": "notion",
  "scopes": ["read", "write"]
}
```

```
HTTP/1.1 200 OK
Content-Type: application/json

{
  "access_token": "eyJ...",
  "token_type": "Bearer",
  "expires_in": 3600,
  "provider": "notion"
}
```

### 補助API

| エンドポイント | 用途 |
|---------------|------|
| `POST /token/exchange` | 有効なアクセストークンを取得 |
| `POST /token/revoke` | トークンの失効 |
| `GET /providers` | 利用可能なプロバイダー一覧 |
| `GET /user/{user_id}/connections` | ユーザーの接続済みサービス一覧 |

### 役割分担の再定義

| 役割 | 責務 | 対象 |
|------|------|------|
| **Token Exchanger Provider** | OAuth連携、トークン管理、セキュリティ | プラットフォーム事業者 |
| **MCP Server開発者** | ツールロジック実装 | 個人〜企業 |
| **MCPクライアント** | ユーザー認証、MCP Server へのアクセス | アプリケーション |
| **エンドユーザー** | サービス利用、OAuth認可 | 利用者 |

### Token Exchanger Provider の候補

Token Exchanger Providerとして適任な事業者:

| 事業者 | 適任理由 |
|--------|---------|
| LLMプラットフォーム事業者 | MCPエコシステムの発展に直接的利益、既存ユーザー基盤 |
| クラウドプラットフォーム事業者 | 認証基盤の運用実績、グローバルインフラ |
| 認証サービス事業者 | OAuth連携の専門知識、多数のプロバイダー対応実績 |

---

## 期待される効果

### 1. 参入障壁の劇的な低下

```
【現状】
OAuth実装 → トークン管理 → セキュリティ対応 → ツール開発
                                               ↑
                                          やっとここから

【Token Exchanger導入後】
ツール開発から開始可能
```

### 2. セキュリティの向上

- トークン管理が専門事業者に集約
- 個別実装によるセキュリティホールの削減
- 監査・コンプライアンス対応の一元化

### 3. エコシステムの統一

- エンタープライズと個人開発者が同じ土俵に
- MCPサーバーの相互運用性向上
- ツールの再利用・共有が容易に

### 4. 開発者体験の向上

```go
// Token Exchanger を利用する場合の実装例
func (m *NotionModule) Execute(ctx context.Context, userID string) error {
    // トークン取得は1行
    token, err := m.tokenExchanger.Exchange(ctx, userID, "notion")
    if err != nil {
        return err
    }

    // 以降はツールロジックに集中
    client := notion.NewClient(token)
    // ...
}
```

---

## MCP仕様との関係

### 互換性

Token Exchanger パターンはMCP仕様と**矛盾しない**:

- MCP Client → MCP Server 間の認証はMCP仕様に準拠
- MCP Server → Token Exchanger 間はMCP仕様の**範囲外**
- 既存のエンタープライズ向け認証（XAA等）との共存が可能

### 標準化の提案

Token Exchanger APIを将来的にMCP仕様の**オプショナルな拡張**として提案することを検討:

```
【MCP認証仕様の拡張案】

必須: MCP Client → MCP Server 認証（現行仕様）

オプション:
  - Enterprise IdP連携（XAA, ID-JAG）← 現行仕様
  - Token Exchanger連携 ← 新規提案
```

---

## 結論

MCP認証仕様は現在、エンタープライズ向けに最適化されており、個人/小規模開発者向けのパターンが欠落している。この状態が続くと、MCPエコシステムの成長が阻害され、プロトコルとしての普及が限定的になるリスクがある。

**Token Exchanger パターン**は、認証インフラをプラットフォーム事業者に委譲することで、MCP開発者がツール開発に集中できる環境を実現する。これにより:

1. 参入障壁の劇的な低下
2. セキュリティの向上
3. エコシステムの統一
4. MCPの持続的な成長

が期待できる。

MCPがプロトコルとして生き残り、広く普及するためには、エンタープライズだけでなく**すべての開発者**がアクセス可能な認証パターンの標準化が不可欠である。

---

## 本提案への批判と応答

### 批判1: 「役割分離が成立しない」という指摘は論点がずれている

**批判内容**:

MCP仕様が前提としているのは「組織分離」ではなく「責務分離（trust boundary）」である。OAuth/MCPは「同一人物が複数ロールを担う」ことを禁止していない。重要なのは「どの主体が、どの秘密情報を保持するか」であって「それを誰が運営しているか」ではない。

「自分が全部やる＝設計が破綻する」という論証は成立しない。これは運用負荷の問題であって、仕様の破綻ではない。

**応答**:

この批判は正しい。役割分離の議論は**仕様の破綻**ではなく**運用負荷**の問題として再定義すべきである。ただし、運用負荷が高すぎることでエコシステムの成長が阻害されるという問題意識自体は維持する。

---

### 批判2: Enterprise IdP依存は「オプション」であり排他的ではない

**批判内容**:

XAA/ID-JAGがEnterprise IdP前提であるのは事実だが、MCP仕様は「すべての利用者に同じ高度な認証を要求している」わけではない。あくまでEnterprise向けのオプションを定義しているだけ。

これは「Kubernetesは個人開発者に重すぎる」と言っているのと同型。重いが間違ってはいない。排他的でもない。

**応答**:

この批判も正しい。Enterprise向け機能の存在自体を批判するのは不適切。ただし、**個人/小規模向けのパターンが未整備**である点は事実であり、その補完が必要という主張は維持する。

---

### 批判3: クライアントにトークンが集中する問題（最も強い指摘）

**批判内容**:

この指摘は「最も強い指摘で、かなり正確」と認められている。統合MCPサーバーが複数サービスを束ねる場合、クライアントが全サービスのトークンを持つことになり、MCP Clientが「巨大IdP」になることを暗黙に要求している。

**応答**:

この問題は本提案の核心的な動機であり、批判者も有効性を認めている。Token Exchanger パターンはこの問題への一つの解答として提案している。

---

### 批判4: 参入障壁の高さはMCP固有の問題ではない

**批判内容**:

OAuth アプリ登録、トークン暗号化、リフレッシュ処理、セキュリティ監査といった負担は事実だが、これはSaaS連携、API統合、Zapier/IFTTT/n8nすべてが抱えている構造的問題。「MCPの欠陥」ではなく「OAuthエコシステム全体の現実」。

**応答**:

この批判は正しい。MCPだけを批判するのは不公平。ただし、MCPが新しいプロトコルとして普及を目指すなら、既存の問題を踏襲するのではなく解決策を提示する機会でもある。

---

### 批判5（最重要）: Token Exchanger は Trust Boundary を崩壊させる

**批判内容**:

Token Exchanger は以下の構造を作る:

```
MCP Server → Token Exchanger → 外部サービス
```

これはMCP Serverが「ユーザーの外部サービス権限を代理行使できる」ことを意味し、実行主体・権限主体・利用主体をすべて同時に担う。**これはOAuthが20年かけて避けてきた設計**。

Token配布APIは危険すぎる:
- MCP Serverの侵害 → 全ユーザー全サービス即死
- 権限スコープの過剰要求
- トークンの二次流出
- 監査不能（「誰が、どの操作をしたか」）

「セキュリティ向上」と主張しているが、集中化は常に単一障害点を生む。

**応答**:

**この批判は最も致命的であり、真摯に受け止める。**

Token Exchanger パターンは確かに Trust Boundary を再編成する。これが正当化されるのは:

1. **統合プラットフォーム**として明確なToSのもとで運営される場合
2. **強制的なスコープ制限**と**操作ログの完全可視化**が担保される場合
3. 運営主体が十分な**セキュリティ監査・コンプライアンス**対応能力を持つ場合

のみである。

単なるMCP Serverがこのパターンを採用することは危険であり、**Zapier/Workato的な「統合プラットフォーム」としての責任を負う覚悟がある場合のみ**適用すべきである。

---

### 批判6: 「MCP仕様と矛盾しない」は形式的に正しいが精神的に矛盾する

**批判内容**:

MCP Client → MCP Server 認証は保持されるが、MCPの思想は「ツールは最小権限で、文脈限定的に呼び出される」こと。Token Exchanger は恒久的なユーザー権限を文脈非依存・MCP Server主導で扱う。これは**MCPの「Contextual Tool Invocation」哲学と逆行**している。

**応答**:

この批判は鋭い。Token Exchanger は確かにMCPの「文脈限定的」という思想から逸脱するリスクがある。

正統派の解決案として以下が提案されている:
- **Client-managed token + Capability delegation**: クライアントが最小スコープ短命トークンを発行
- **Per-call ephemeral token**: ツール呼び出し単位で失効
- **MCP-native consent UI**: 「このツールがこの操作をします」という同意取得

これらは理想的だが、現時点で誰も実装していない。Token Exchanger はこれらが実現されるまでの**過渡的な現実解**として位置づけるべきかもしれない。

---

## 結論（修正版）

Token Exchanger パターンは、MCP認証仕様の空白を埋める一つの解答として提案したが、以下の重大なトレードオフがある:

| メリット | リスク |
|---------|--------|
| 参入障壁の劇的な低下 | Trust Boundary の崩壊 |
| 開発者体験の向上 | 単一障害点の生成 |
| OAuth実装の集約 | MCPの「文脈限定」思想との矛盾 |

**本提案が正当化されるのは「統合プラットフォーム」としての運営責任を負う場合のみ**であり、一般的なMCP Serverが無条件に採用すべきパターンではない。

MCPエコシステムの健全な成長のためには、Token Exchanger のような現実解と並行して、**Per-call ephemeral token** や **MCP-native consent UI** といった正統派の解決策の標準化を進めることが望ましい。

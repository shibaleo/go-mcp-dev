# MCPist 設計哲学

## MCPist: Managing Context Personally

**MCPistは、自前でOAuthトークンを管理できるパワーユーザーが、自分の複数アカウントを単一のMCPサーバー経由で並列的に利用するためのセルフホスト型ツールである。**

### 研究背景: 認知資源のマネジメント

MCPistは、より深い研究課題から生まれた：

> **認知資源の管理、通知管理、注意資源の管理**

これらは長年取り組んできた中核的な課題である。

#### Information Flood から Context Rot へ

**Information Flood（情報洪水）** は1970年代から認識されてきた問題である。Alvin Tofflerは「Future Shock」で情報過負荷を警告し、インターネット普及後は日常的な課題となった。

これに対する個人の解決策として **PKM（Personal Knowledge Management）** が生まれた。

```
【歴史的連続性】

1970s: Information Flood（情報洪水）の認識
  ↓ 個人の解決策として
2000s: PKM（Personal Knowledge Management）の台頭
  ↓ LLMの登場で新たな次元が加わる
2020s: Context Rot（LLMの認知に対する情報洪水）
  ↓ 個人の解決策として
2025-: PCM（Personal Context Management）の必要性
```

**Information FloodはLLMにとってのContext Rotと同型の問題である。**

- Information Flood = 人間の認知に対する情報過負荷
- Context Rot = LLMの認知に対する情報過負荷

LLMの登場により、自分自身の注意だけでなく、**LLMが何に注意を向けるか**も管理しなければならなくなった。

MCPistは、PKMの原則をLLM時代に適用したものである。知識システム自体が能動的な推論パートナーとなった時代の、PKMの次章だ。

### A Quiet Game Changer

> **A quiet game changer for people who already know too much.**

「know too much」には二重の意味がある：

1. 膨大な個人知識システムを蓄積してきた人々
2. コンテキストのオーバーフローがユーザーのエラーではなく構造的問題だと理解している人々

MCPistは万人向けではない。自分のツール、ワークフロー、注意を長年キュレーションしてきた人々のためのものだ。

そういう人々にとって、MCPistは新たな負担ではない。**欠けていた最後のピース**である。

### LLM推論可能世界のパーソナライズ

MCPistの本質は、**LLMが「何を知り、何ができるか」を個人がコントロールする**ことにある。

```
【従来】
LLMの推論可能世界 = モデルベンダーが決めた範囲
  → 全ユーザー共通のツールセット
  → 平均的ユーザー向けに最適化
  → 個人の文脈は反映されない

【MCPist】
LLMの推論可能世界 = 自分が定義した範囲
  → 自分のアカウント（Notion、GitHub、Jira...）
  → 自分が認証したサービスのみ
  → 自分の文脈に特化
```

| 観点 | ベンダー提供 | MCPist |
|------|------------|--------|
| **何を知るか** | 平均的ユーザー向け情報 | 自分のNotion、自分のGitHub |
| **何ができるか** | 汎用ツールセット | 自分が認証したサービスのみ |
| **どこまで知るか** | ベンダーの制限（40〜128ツール） | 自分が許可した範囲 |

MCPistは単なる「ツール統合」ではなく、**LLMの認知境界を個人が設計する**ためのツールである。

### シングルテナント・シングルユーザー・マルチアカウント

#### 用語定義

| 用語 | 定義 | 例 |
|------|------|-----|
| **テナント（Tenant）** | 組織的な責任単位・権限集約単位 | 会社A、個人事業主B |
| **ユーザー（User）** | 操作主体としての個人 | 田中さん、鈴木さん |
| **アカウント（Account）** | ユーザーに紐づく、論理的に分離された権限インスタンス | Notion個人用、GitHub仕事用 |

#### MCPの構造比較

| 構造 | テナント | ユーザー | アカウント | 例 |
|------|---------|---------|-----------|-----|
| **従来のMCP** | シングル | シングル | シングル | 1サービス専用MCPサーバー |
| **MCPist** | シングル | シングル | **マルチ** | 複数サービス統合MCPサーバー |
| **Pooled Multi-Tenant** | マルチ | マルチ | マルチ | Zapier的プラットフォーム |

```
【MCPist: シングルテナント・シングルユーザー・マルチアカウント】

テナント: 自分（1）
  └─ ユーザー: 自分（1）
       └─ アカウント1（Notion個人）
       └─ アカウント2（GitHub仕事用）
       └─ アカウント3（Jira副業用）

→ 1サーバーで複数アカウントを管理 = インフラ節約
→ Trust Boundary維持（全部自分の権限）
```

### ターゲットユーザー

- OAuthアプリ登録・トークン管理ができる技術力がある
- 複数サービスを個別にMCP化する運用負担を避けたい
- LLMはClaude/GPT等の外部サービスを使うが、**データの権限は自分で管理したい**
- モデルベンダーに依存せず、自分のトークン・自分の権限で外部サービスを操作したい

### MCPistが提供する価値

| 価値 | 説明 |
|------|------|
| **ツール統合の集約** | Notion, GitHub, Jira等を個別にMCP化する手間を省く |
| **並列実行基盤** | DAG/Goスクリプトによるサーバーサイド並列化 |
| **Context Rot防止** | メタツールパターンでLLMのコンテキスト消費を抑制 |

### MCPistが提供しないもの

| 提供しないもの | 理由 |
|---------------|------|
| OAuthアプリの登録代行 | ユーザー自身の権限として管理すべき |
| トークン取得の自動化 | ユーザーが自分で認可フローを完了する |
| モデルベンダーへの依存 | Claude APIキー等は各自で用意 |
| 他人のトークン集約 | Trust Boundary崩壊を避ける |

### 何でないか

MCPistは**Zapier的な「誰でも使えるノーコードプラットフォーム」ではない**。

- 参入障壁を下げるためのToken Exchangerパターンは採用しない
- ユーザー**自身の**トークンを預かって代理実行するセルフホスト型ツール
- 他人のトークンを集約する「統合プラットフォーム」とは異なるセグメント

**なぜマルチテナント・マルチユーザーではないか**：

他人のトークンを預かる構造（Pooled Multi-Tenant）は、Token Exchanger批判で指摘された「Trust Boundary崩壊」を引き起こす。MCPistがToken Exchangerを批判しながら同じ構造を採用することは自己矛盾となる。

MCPistの「マルチアカウント」機能は、**従来のシングルアカウントMCPサーバーを複数運用する煩雑さ・インフラオーバーヘッドを避けるための節約手段**に過ぎない。

---

## 設計原則

### 1. オーケストレーターであり、エージェントではない

MCPistは「プラットフォーム」ではなく「ツール統合・ルーティング」に徹する。判断・解釈はユーザーLLMに委ね、MCPistは決定論的な処理のみを行う。

**やること:**
- ルーティング（リクエストを適切なモジュールへ振り分け）
- スキーマの動的取得・返却
- 認証・認可のプロキシ
- エラーハンドリングの統一
- 依存解決（タスク間の依存関係をグラフとして解決）

**やらないこと:**
- データの永続化（呼び出し結果を保存しない、ベクトル化しない、要約しない）
- 判断・選択（どのツールを呼ぶかはLLM側の責任）
- コンテキスト生成（RAGしない、メモリ構築しない）
- 非決定論的なデータ変換（要約、統合、再構成などLLMが必要な処理）

### 2. 決定論的処理に徹する

MCPistは「低コンテキスト・浅い推論」を超える処理をしない。

**許可する操作（決定論的）:**
```
${results | where status == "open"}     # フィルタリング
${results | sort_by created_at desc}    # ソート
${results | pluck id, name}             # 抽出
${results | join other_results on id}   # 結合
${results | format_as json}             # フォーマット
```

**許可しない操作（非決定論的）:**
```
${results | summarize}                  # 要約
${results | merge_intelligently}        # 統合
${results | pick_best}                  # 判断
```

こういう語彙を持った瞬間、MCPistはLLMになる。

### 3. 責任境界を明確にする

中間結果はユーザーLLMのコンテキストを通過する。これによりコンテキスト消費は増えるが、「誰が判断したか」が明確になる。

| アプローチ | コンテキスト消費 | 責任境界 |
|-----------|----------------|---------|
| MCPistが解釈する | 低 | 曖昧 |
| ユーザーLLMが具体化する | 高 | 明確 |

**MCPistは後者を選択する。** コンテキスト消費は「責任を明確にするためのコスト」として受け入れる。

---

## Designative Liability（設計的責任）

MCPistがLLMを持つとどうなるか:

- ツール選択の判断責任がMCPistに移る
- 結果の要約・フィルタリングの判断責任も発生
- 「何を返さないか」の決定権を持つことになる

MCPistがLLMを持つと、「この結果で十分」「このツールが適切」という**意味の定義責任**を負う。これはオーケストレーターではなくエージェントになるということ。

### 具体的な問題

| 問題 | 説明 |
|------|------|
| コスト構造の変化 | MCPist側でLLM呼び出しコストが発生。誰が払う？ |
| 障害点の増加 | 内部LLMの判断ミスはユーザーのLLMには見えない |
| 責任の曖昧化 | 悪い結果が返ったとき、誰の責任？ |

---

## MCPistの本質的革新: Context Rot問題の解決

### 本質的課題: Context Rot

LLMのコンテキストウィンドウが大量のツール定義で埋め尽くされ、実際のタスク処理に使えるトークン数が減少する問題。これがMCPエコシステムの根本的課題である。

### 業界の対応状況（2025年時点）

「Too Many Tools Problem」として業界でも認識されており、各社が制限を設けている：

| プラットフォーム | ツール数制限 | 対応策 |
|-----------------|------------|--------|
| Cursor | **40ツール** | 上限制限 |
| GitHub Copilot | **128ツール** | 上限制限 |
| GitHub MCP Server | - | tool-specific configuration（60-90%コンテキスト削減） |

しかし、これらは**ベンダー側の制限**であり、個人ユーザーが自分のコンテキストを最適化する手段は提供されていない。

### なぜ企業（モデルベンダー）は根本解決しないか

- モデルベンダーにとってContext Rotを直す動機が薄い
- コンテキスト消費が増えれば課金が増える構造
- 制限を設けてもビジネス/モデルに吸収される（ユーザー視点では解決にならない）
- **個人が自分のコンテキストをマネジメントする手段が存在しない**

これが「Personal Context Management Tool」としてのMCPistの独自性である。

### MCPistの解決アプローチ

| Step | 課題 | 解決策 |
|------|------|--------|
| 1 | 全ツール一括公開 | メタツールで遅延読み込み |
| 2 | 累積コンテキスト問題 | マルチアカウントでフィルタリング |
| 3 | MCP仕様の壁 | get_module_schema実行時にフィルター |

### MCP仕様の根本的制約

MCP標準プロトコルは**シングルアカウント前提**で設計されている：

- 1接続 = 1ユーザー = 1アカウント = 1権限セット
- `tools/list`はinitialize時に全ツールを返す
- エンタープライズIdPでユーザーを識別しても、**同一ユーザーの複数アカウントを区別する仕組みは仕様にない**

この前提は今後も変更されない。その証拠がエンタープライズIdP設計であり、「組織内の誰か」を識別することはあっても「その人のどのアカウントか」を区別する必要性は想定されていない。

### メタツールによる事前フィルタリング

```
【従来のMCP】
initialize → tools/list → 全100ツール公開
→ LLMが100ツールから選択を推論（コンテキスト消費大、推論精度低下）

【MCPist】
initialize → tools/list → メタツールのみ公開
get_module_schema("notion") → 認証情報を検証 → 該当アカウントの15ツールのみ返却
→ LLMは事前フィルター済みのツールから選択（コンテキスト節約、推論高品質化）
```

| 効果 | 説明 |
|------|------|
| **Context Rot防止** | 不要なツールスキーマを読み込まない |
| **推論の高品質化** | LLMに「どのツールを使うか」を大量候補から推論させない |
| **マルチアカウント対応** | 認証情報ベースのフィルタリングを実現 |

### MCPistの位置づけ: コンテキストマネジメントツール

MCPistは、プロンプトエンジニアリング → コンテキストエンジニアリングに続く**コンテキストマネジメント**の実践である。

| 世代 | 手法 | 特徴 |
|------|------|------|
| プロンプトエンジニアリング | プロンプトの書き方を最適化 | 入力の質を上げる |
| コンテキストエンジニアリング | コンテキストウィンドウ全体を設計 | 人間が何を入れるか管理 |
| **コンテキストマネジメント** | システムが自動最適化 | 実行時動的フィルタリング |

### シングルユーザーだからこそ可能なパーソナライズ

MCPistはシングルユーザー前提であるため、**大手ベンダーが踏み込めない領域**に踏み込める。

大手ベンダーは不特定多数のユーザーを想定するため、コンテキストは「平均的ユーザー」向けに最適化される。個人の嗜好・習慣・ワークフローを反映できず、プライバシー・コンプライアンス上、個人情報を保持しにくい。

MCPistは1人格 = 1インスタンスであるため：
- コンテキストに個人的情報を自由に組み込める
- 自分のデータなのでプライバシー問題なし
- アカウントごとの使い分けルールを設定可能

| 観点 | 大手ベンダー | MCPist |
|------|------------|--------|
| ユーザーモデル | 平均化・汎用 | 個別・特化 |
| 個人情報 | 扱えない/扱いにくい | 自由に組み込み可能 |
| 学習・適応 | 全ユーザー共通 | 自分専用にカスタマイズ |
| プライバシー | 規制対象 | 自己管理 |

---

## 提供機能

MCPistは全ツールをtools/listで公開しない。代わりにメタツールを提供し、Context Rotを防ぐ。

### 1. get_module_schema

指定モジュールのツール定義を取得する。

- **入力**: モジュール名
- **出力**: 指定モジュールのツール定義
- **性質**: 決定論的（フィルタリングだけ）

ユーザーLLMが「どのモジュールが必要か」を判断し、MCPistは指定されたスキーマを返すだけ。

### 2. call_module_tool

指定モジュールの指定ツールを実行する。

- **入力**: モジュール名、ツール名、引数
- **出力**: 実行結果
- **性質**: 決定論的（指定された通りに実行）

### 3. execute_dag

依存関係を持つ複数タスクをDAGとして並列実行する。

- **入力**: タスク配列（短いパラメータ、依存関係）
- **出力**: 全タスクの実行結果
- **性質**: 決定論的（トポロジカルソート→並列実行→変数展開）

DAGに適するのは短いパラメータ（ID、フラグ、数値）の読み取り中心タスク。

### 4. execute_go

Goスクリプトをサンドボックス内で実行する。

- **入力**: Goスクリプト
- **出力**: 実行結果
- **性質**: 決定論的（MCPistは実行するだけ）

複雑な制御フロー、長文パラメータの構築、条件分岐、ループ処理が可能。

### 使い分けの判断

MCPistは内部で判断・切り替えをしない。指定された通りに実行する。

| ユーザーの意図 | フロー |
|---------------|--------|
| **シングルタスク** | get_module_schema → call_module_tool |
| **マルチタスク**（並列・依存関係あり） | get_module_schema → DAG生成 → execute_dag |
| **複雑なタスク**（条件分岐・ループ等） | get_module_schema → Goスクリプト作成 → execute_go |

どのパターンを選択するかの判断はLLM側の責任。MCPistはツールスキーマのdescriptionで使い分けの「推奨」を伝えるだけ。

---

## セキュリティ

### execute_go のサンドボックス

悪意のあるコードへの対策として、Goパーサーで以下を保証する：

- 標準モジュールと基本関数（for, if等）のみ許可
- 禁止事項：
  - 通信（net, http等）
  - ファイルシステムアクセス
- 無限ループ対策：ランタイムでカウンタ制限
- 何を「基本関数」とするかは別途定義

### エラーハンドリング

execute_dag失敗時の振る舞い：

- エラー内容とその時点で取得した情報を返却
- **全体ロールバックは行わない**
- エラーを見てそのあと何をするかは**ユーザーLLMとユーザーが判断**

決定論的オーケストレーターとして、判断はユーザー側に委ねる。

---

## 実装基盤

### MCP公式Go SDK

MCPistは公式Go SDK（https://github.com/modelcontextprotocol/go-sdk）を土台として構築する。

**公式SDKから利用するもの:**
- `mcp.Server`: サーバー構造体
- `mcp.AddTool()`: メタツール登録
- `StreamableHTTPHandler`: HTTP/SSEサーバー
- セッション管理機構

**MCPistが独自に構築するもの:**
- メタツール設計（get_module_schema, call_module_tool等）
- モジュールの動的スキーマ返却
- Context Rot対策（全ツールをtools/listで公開しない）

| 公式SDKの想定 | MCPistの拡張 |
|--------------|-------------|
| 全ツールをtools/listで公開 | メタツールのみ公開、モジュールは動的取得 |
| 1サーバー = 1機能セット | 1サーバー = 複数モジュールのオーケストレーター |
| Context Rotは考慮外 | Context Rot対策がコア機能 |

---

## まとめ

MCPistは：

1. **パワーユーザー向けのセルフホスト型MCP統合ツール**である
2. **オーケストレーター**であり、エージェントではない
3. **決定論的処理**に徹し、非決定論的判断はユーザーLLMに委ねる
4. **責任境界を明確に**し、コンテキスト消費をそのコストとして受け入れる
5. ユーザー**自身の**トークンを管理し、Trust Boundaryを維持する

# ADR-003: メタツール + 選択的スキーマ取得パターンの採用

## ステータス

**Accepted** (2025-01-11)

## コンテキスト

MCP仕様では、`tools/list`はinitialize時に**全ツールを一括で返す**ことが期待されている。これはContext Rotの直接的な原因となる。

```
【MCP仕様の想定フロー】
initialize → tools/list → 全100ツール公開
→ LLMが100ツールから選択を推論
→ コンテキスト消費大、推論精度低下
```

Context Rotは業界で既に認識されている問題である（「Too Many Tools Problem」）。各社は以下の対応を行っている：

| プラットフォーム | 対応策 |
|-----------------|--------|
| Cursor | 40ツール上限 |
| GitHub Copilot | 128ツール上限 |
| GitHub MCP Server | tool-specific configuration（静的フィルタリング） |

しかし、これらは**ベンダー側の制限**であり、個人ユーザーが自分のコンテキストを最適化する手段ではない。公式MCPによるツール制約はユーザーの個人的な必要を満たすことができず，平均化されたツールの使用を強制されてしまう．

## 決定

MCPistは**メタツール + 選択的スキーマ取得**パターンを採用する。

### メタツール設計

initialize時に公開するのはメタツール：

```json
{
  "tools": [
    {
      "name": "get_module_schema",
      "description": "モジュールのツール定義を取得"
    },
    {
      "name": "call",
      "description": "モジュールのツールを単発実行"
    },
    {
      "name": "batch",
      "description": "JSONL形式で複数ツールを一括実行（afterで依存指定、output:trueで結果返却）"
    }
  ]
}
```

### 選択的スキーマ取得フロー

```
【MCPistのフロー】
initialize → tools/list → メタツールを公開（3ツール）
ユーザー: 「Notionのページを検索して」
LLM: get_module_schema("notion") を呼び出し
MCPist: Notionモジュールの15ツールを返却
LLM: call({module: "notion", tool_name: "search", params: {...}}) を呼び出し
→ 必要なモジュールだけオンデマンド取得
→ コンテキスト節約、推論高品質化
```

## 理由

### 1. MCP仕様との互換性維持

メタツールパターンはMCP仕様を**逸脱しない**。

- `tools/list`は正常に応答する（メタツールを返す）
- ツール呼び出しは標準的なJSON-RPCで行われる
- プロトコルレベルでの変更は不要

MCP仕様の制約内で、その意図しない問題（Context Rot）を解決している。

### 2. 事前フィルタリングの実現

MCPist原則の核心：

> **If a tool should not be used, it should never exist in context.**

アカウントごとのトークンに紐づくプロフィール照合により、フィルタリングは**推論の前**に行われる。LLMに「どのツールを使うか」を大量候補から推論させない。

### 3. GitHub MCP Serverとの差異

GitHub MCP Serverも「tool-specific configuration」でContext Rot対策を行っている。しかし両者のアプローチは根本的に異なる：

| 観点 | GitHub MCP Server | MCPist |
|------|------------------|--------|
| フィルタリング | **静的**（設定時に決定） | **動的**（実行時にオンデマンド） |
| 機能 | 設定したツール以外は**使用不可** | 全ツールが**利用可能**、必要時に読み込み |
| 制御主体 | 設定ファイル（ヘッダー/CLI） | LLMの判断 + メタツール |
| 目的 | 機能制限によるコンテキスト削減 | 機能維持しつつコンテキスト最適化 |

GitHub: **機能を減らしてコンテキストを減らす**
MCPist: **機能を維持しつつコンテキストを最適化する**

### 4. マルチアカウント対応の副次効果

メタツールパターンは、MCP仕様の別の制約も同時に解決する。

MCP標準プロトコルは**シングルアカウント前提**（1接続 = 1ユーザー = 1アカウント）で設計されている。同一ユーザーの複数アカウント（Notion個人用、GitHub仕事用など）を区別する仕組みは仕様にない。

メタツールにより：
- `get_module_schema`呼び出し時にアカウントの認証情報を検証
- 該当アカウントのツールのみを返却
- MCP仕様を逸脱せずにマルチアカウント対応を実現

## 影響

### 採用するもの

- `get_module_schema`: モジュール単位のスキーマ取得
- `call`: 単発ツール実行（プリミティブ）
- `batch`: JSONL形式で複数タスクを一括実行（`after`で依存指定、`output:true`で結果返却）
- モジュール単位の認証情報管理
- LLMへの1セッションあたり1回のみスキーマ取得推奨
- batchでカバーできない複雑な制御フローはLLMとの対話で解決

## 代替案

### 案A: 全ツール一括公開（MCP標準）

**却下理由**: Context Rotの直接的原因。MCPistの存在意義がなくなる。

### 案B: 静的フィルタリング（GitHub方式）

**却下理由**: 機能が減る。「このツールは使えない」状態が生まれる。

### 案C: LLMによる動的選択

**却下理由**: LLMに「どのツールを使うか」を推論させること自体がContext Rotの一部。フィルタリングは推論の前に行うべき。

### 案D: メタツール + 選択的スキーマ取得（採用）

**採用理由**: MCP仕様互換、機能維持、コンテキスト最適化、マルチアカウント対応を同時に実現。

## 結論

メタツール + 選択的スキーマ取得パターンは、MCPistの技術的核心である。

業界で認識されているContext Rot問題を、**「個人が解決すべき課題」として位置づけ**、MCP仕様の制約内で解決する手段を提供する。

これはGitHub MCP Serverの静的フィルタリングとは異なり、**機能を維持しつつコンテキストを最適化する**アプローチである。

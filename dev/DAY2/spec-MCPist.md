# MCPist 仕様書

## 概要

MCPistは、**Personal Context Management（個人コンテキスト管理）** のためのセルフホスト型MCPサーバーである。

LLMが「何を知り、何ができるか」を個人がコントロールし、Context Rot（コンテキストの腐敗）を防ぐことを目的とする。

---

## システム構成

### 全体アーキテクチャ

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           ユーザー環境                                   │
│  ┌─────────────────┐                                                    │
│  │  LLMクライアント  │  Claude Code, Cursor, GitHub Copilot等            │
│  │  (MCP Client)   │                                                    │
│  └────────┬────────┘                                                    │
│           │ MCP Protocol (JSON-RPC 2.0 over SSE)                        │
│           │ Authorization: Bearer <JWT>                                 │
└───────────┼─────────────────────────────────────────────────────────────┘
            │
            ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                         MCPサーバー                                      │
│                    （コンテナホスティング）                                │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  認証ミドルウェア                                                  │   │
│  │  - JWT検証（Authサーバー発行トークン）                              │   │
│  │  - user_accountID抽出                                             │   │
│  └───────────────────────────┬─────────────────────────────────────┘   │
│                              │                                          │
│  ┌───────────────────────────▼─────────────────────────────────────┐   │
│  │  MCPプロトコルハンドラ                                             │   │
│  │  - JSON-RPC 2.0リクエスト処理                                      │   │
│  │  - SSEセッション管理                                               │   │
│  │  - メタツールルーティング                                           │   │
│  └───────────────────────────┬─────────────────────────────────────┘   │
│                              │                                          │
│  ┌───────────────────────────▼─────────────────────────────────────┐   │
│  │  モジュールレジストリ      (拡張可能)                               │   │
│  │  ┌─────────┬─────────┬─────────┬─────────┬─────────┐            │   │
│  │  │ Notion  │ GitHub  │  Jira   │Confluence│ Supabase│  ...      │   │
│  │  │ 15ツール │ 24ツール │ 14ツール │ 13ツール │ 18ツール │            │   │
│  │  └─────────┴─────────┴─────────┴─────────┴─────────┘            │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                              │                                          │
└──────────────────────────────┼──────────────────────────────────────────┘
                               │
    ┌──────────────────────────┼──────────────────────────┐
    │                          │                          │
    ▼                          ▼                          ▼
┌─────────────────┐  ┌─────────────────┐  ┌───────────────────┐  ┌───────────────────┐
│   Authサーバー   │  │ Token Exchanger │  │    外部API群       │  │  オブザーバビリティ │
│   (OAuth2.1)    │  │ (暗号化Vault)    │  │                   │  │                   │
│                 │  │                 │  │  - Notion API     │  │  - ログ収集        │
│ - ユーザー認証   │  │ - OAuthトークン  │  │  - GitHub API     │  │  - メトリクス      │
│ - JWT発行       │  │   暗号化保存     │  │  - Jira API       │  │                   │
│ - セッション管理 │  │ - トークン       │  │  - Confluence API │  │                   │
│                 │  │   自動リフレッシュ│  │  - Supabase API   │  │                   │
│                 │  │                 │  │  - Google等       │  │                   │
└─────────────────┘  └────────┬────────┘  └───────────────────┘  └───────────────────┘
                              │                     ▲
                              │                     │ access_token
                              ▼                     │
┌─────────────────────────────────────────────────────────────────────────┐
│                    外部サービス OAuth2.0 認可サーバー群                   │
│                                                                         │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐       │
│  │   Google    │ │   GitHub    │ │  Atlassian  │ │   Notion    │  ...  │
│  │  OAuth2.0   │ │  OAuth2.0   │ │  OAuth2.0   │ │  OAuth2.0   │       │
│  │             │ │             │ │             │ │             │       │
│  │ - 認可      │ │ - 認可      │ │ - 認可      │ │ - 認可      │       │
│  │ - トークン   │ │ - トークン   │ │ - トークン   │ │ - トークン   │       │
│  │   発行      │ │   発行      │ │   発行      │ │   発行      │       │
│  │ - リフレッシュ│ │ - リフレッシュ│ │ - リフレッシュ│ │ - リフレッシュ│       │
│  └──────▲──────┘ └──────▲──────┘ └──────▲──────┘ └──────▲──────┘       │
│         │              │              │              │                 │
└─────────┼──────────────┼──────────────┼──────────────┼─────────────────┘
          │              │              │              │
          └──────────────┴──────┬───────┴──────────────┘
                                │ OAuth2.0アプリ登録・認可
                                │
┌───────────────────────────────┴─────────────────────────────────────────┐
│                           管理UI                                         │
│                                                                         │
│  ユーザーが各外部サービスのOAuthアプリケーションを登録・認可する             │
│                                                                         │
│  1. 外部サービスのOAuthアプリ登録（Client ID / Secret取得）                │
│  2. 認可フロー実行（redirect → 同意 → callback）                         │
│  3. 取得したトークンをVaultに暗号化保存                                    │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 認証の二層構造

MCPistは2つの独立した認証レイヤーを持つ：

| レイヤー | 役割 | プロトコル | 担当コンポーネント |
|---------|------|-----------|------------------|
| **MCPサーバー認証** | LLMクライアント → MCPサーバー | OAuth2.1 (JWT) | Authサーバー |
| **外部サービス認証** | MCPサーバー → 外部API | OAuth2.0 (各サービス) | Token Exchanger |

```
【MCPサーバー認証（OAuth2.1）】
                              Authサーバー
                              - ユーザー認証
                              - JWT発行
                                    │
                                    ▼
LLMクライアント ──Bearer JWT──▶ MCPサーバー
                              - JWT検証
                              - user_accountID抽出

【外部サービス認証（OAuth2.0）】
Token Exchanger (Vault) ── refresh_token ──▶ 外部サービスOAuth2.0認可サーバー
         │                                       │
         │◀─────── access_token ─────────────────┘
         │
         ▼
    MCPサーバー ──access_token──▶ 外部API (Notion, GitHub等)
```

---

## コンポーネント詳細

### 1. MCPサーバー

MCPサーバーは**純粋な計算サーバー**として動作し、決定論的処理のみを行う。

#### 役割

| 機能 | 説明 |
|------|------|
| ルーティング | リクエストを適切なモジュールへ振り分け |
| スキーマ動的取得 | メタツール経由でモジュールスキーマを返却 |
| 認証プロキシ | Token Exchangerから取得したトークンで外部API呼び出し |
| エラーハンドリング | 統一されたエラー形式で応答 |

#### やらないこと

| 機能 | 理由 |
|------|------|
| データ永続化 | 呼び出し結果を保存しない、ベクトル化しない |
| 判断・選択 | どのツールを呼ぶかはLLM側の責任 |
| 非決定論的変換 | 要約、統合、再構成などLLMが必要な処理 |
| バックエンドLLM | 推論処理はユーザーLLMに委ねる |

#### 完全ステートレス設計

サーバーは状態を持たない。毎リクエストでToken Exchangerからトークンを取得し、処理完了後に状態は残らない。

```
リクエスト受信 (Bearer JWT)
    │
    ▼
認証ミドルウェア: JWT検証 → user_accountID抽出
    │
    ▼
Token Exchanger: OAuthトークン取得（リトライ付き）
    │         ※期限切れの場合は自動リフレッシュ
    ▼
ツール実行（取得したトークンで外部API呼出）
    │
    ▼
レスポンス返却
（状態は何も残らない）
```


#### ユーザーレベルマスク

- ツール実行の際にToken Exchangerからシークレットだけでなくユーザー(アカウント)ごとに利用可能・実行可能なツールの情報を取得する．これにより，ユーザーレベルでLLMから見えるツールのマスク制御が可能．

---

### 2. Token Exchanger（Vault）

Token Exchangerは、MCPサーバーと外部サービス間の認証を仲介する。

#### 構成要素

| コンポーネント           | 役割                       |
| ----------------- | ------------------------ |
| **Vault**         | 外部サービスのOAuthトークンを暗号化保存   |
| **Edge Function** | トークン取得・リフレッシュ処理          |
| ユーザープロフィール        | 各ユーザーがどのツールをLLMに見せたいかを指定 |

#### 認証フロー

```
【初回セットアップ】
1. ユーザーがAuthサーバーでログイン
2. 管理UIで外部サービスのOAuth認可を実行
3. 取得したトークンをVaultに暗号化保存

【ツール実行時】
1. MCPクライアントがJWTをMCPサーバーに送信
2. MCPサーバーがJWTを検証、userIDを抽出
3. Edge FunctionがuserIDに紐づくトークン・プロフィールをVaultから取得
4. 期限切れの場合はリフレッシュトークンで自動更新
5. MCPサーバーが取得したトークンで外部API呼び出し・プロフィールによるマスク
```

#### セキュリティ

| 項目 | 仕様 |
|------|------|
| 暗号化アルゴリズム | AES-256-GCM（認証付き暗号化） |
| キー管理 | バックエンドで自動管理 |
| 通信 | 全接続でTLS 1.3 |
| トークン保存 | リフレッシュトークンは必ず暗号化 |

---

### 3. モジュールレジストリ

外部サービスへのアクセスを提供するモジュールの集合。モジュールの数や中身はあとから改変可能

#### モジュール一覧

| モジュール | ツール数 | 機能 |
|-----------|---------|------|
| Notion | 15 | ページ・データベース・ブロック・コメント操作 |
| GitHub | 24 | リポジトリ、Issue、PR、Actions、コード検索 |
| Jira | 14 | Issue/Project操作、コメント、ワークログ |
| Confluence | 13 | Space/Page操作、CQL検索、ラベル |
| Supabase | 18 | プロジェクト管理、SQL実行、マイグレーション |
| Google Calendar | - | 予定の取得・作成（予定） |
| Microsoft Todo | - | タスク管理（予定） |

#### モジュール構造

各モジュールは以下を定義する：

- **モジュール名**: 識別子
- **説明**: モジュールの機能説明
- **APIバージョン**: 外部APIのバージョン文字列
- **ツール一覧**: 提供するツールの配列
- **ハンドラ**: 各ツールの実行関数

---

## メタツール設計

MCPistは全ツールを`tools/list`で公開しない。代わりにメタツールを提供し、Context Rotを防ぐ。

### Context Rot問題

```
【従来のMCP】
initialize → tools/list → 全100ツール公開
→ LLMが100ツールから選択を推論
→ コンテキスト消費大、推論精度低下

【MCPist】
initialize → tools/list → メタツールのみ公開（3ツール）
get_module_schema("notion") → 該当モジュールの15ツールのみ返却
→ 必要なモジュールだけオンデマンド取得
→ コンテキスト節約、推論高品質化
```

### メタツール一覧

initialize時に公開するのはメタツールのみ：

```json
{
  "tools": [
    { "name": "get_module_schema", "description": "モジュールのツール定義を取得" },
    { "name": "call", "description": "モジュールのツールを単発実行" },
    { "name": "batch", "description": "JSONL形式で複数ツールを一括実行（afterで依存指定、output:trueで結果返却）" }
  ]
}
```

### メタツール仕様

#### get_module_schema

指定モジュールのツール定義を取得する。

- 会話の中で一度呼ばれたツール定義が再度呼ばれないように、コンテキストに含める（スキーマキャッシュ）
- ユーザープロフィールに基づくツールマスク適用

| 項目 | 値 |
|------|-----|
| 入力 | モジュール名 |
| 出力 | 指定モジュールのツール定義（ユーザーマスク適用済み） |
| 性質 | 決定論的（フィルタリングのみ） |

```json
{
  "module": "notion"
}
```

#### call

指定モジュールの指定ツールを単発実行する。

- 最もシンプルなツール呼び出し（プリミティブ）
- `batch`の内部でも使用される基本操作

| 項目 | 値 |
|------|-----|
| 入力 | モジュール名、ツール名、パラメータ |
| 出力 | 実行結果 |
| 性質 | 決定論的（指定された通りに実行） |

```json
{
  "module": "notion",
  "tool_name": "search",
  "params": { "query": "会議メモ" }
}
```

#### batch

複数タスクをJSONL形式で一括実行する。

- 1行1タスク、依存関係は`after`で指定
- `after`なしのタスクは並列実行
- 前のタスクの出力を`${id.path}`で参照可能
- `output:true`のタスクのみ結果を返却（コンテキスト節約）
- batchでカバーできない複雑な制御フロー（条件分岐、ループ等）は、LLMとの対話で解決

| 項目 | 値 |
|------|-----|
| 入力 | JSONL文字列（1行1タスク） |
| 出力 | `output:true`のタスクの実行結果のみ |
| 性質 | 決定論的（依存解決 → 並列実行 → 変数展開） |

```jsonl
{"id":"search","module":"notion","tool":"search","params":{"query":"会議メモ"}}
{"id":"get_page","module":"notion","tool":"get_page","params":{"page_id":"${search.results[0].id}"},"after":"search","output":true}
```

**フィールド仕様**:
| フィールド | 必須 | 説明 |
|-----------|------|------|
| `id` | ○ | タスク識別子（変数参照に使用） |
| `module` | ○ | モジュール名 |
| `tool` | ○ | ツール名 |
| `params` | △ | ツールパラメータ |
| `after` | × | 依存タスクID（単一または配列） |
| `output` | × | `true`で結果をLLMに返却（デフォルト: false） |

---

## 設計原則

### 1. シングルテナント・シングルユーザー・マルチアカウント

| 用語 | 定義 |
|------|------|
| テナント | 組織的な責任単位（= 自分1人） |
| ユーザー | 操作主体としての個人（= 自分1人） |
| アカウント | 論理的に分離された権限インスタンス（= 複数可） |

```
テナント: 自分（1）
  └─ ユーザー: 自分（1）
       └─ アカウント1（Notion個人用）
       └─ アカウント2（GitHub仕事用）
       └─ アカウント3（Jira副業用）
```

この構造により：
- 1サーバーで複数アカウントを管理（インフラ節約）
- Trust Boundary維持（全て自分の権限）
- 他人のトークンを預からない（Token Exchanger批判との整合性）

### 2. オーケストレーターであり、エージェントではない

MCPistは判断・解釈をしない。決定論的な処理のみを行い、非決定論的判断はユーザーLLMに委ねる。

| アプローチ | コンテキスト消費 | 責任境界 |
|-----------|----------------|---------|
| MCPistが解釈する | 低 | 曖昧 |
| ユーザーLLMが具体化する | 高 | 明確 |

**MCPistは後者を選択する。** コンテキスト消費は「責任を明確にするためのコスト」として受け入れる。

### 3. 決定論的処理に徹する

許可する操作（決定論的）：
- 指定されたツールの呼び出し

許可しない操作（非決定論的）：
- フィルタリング、ソート、抽出、結合、フォーマット
- 要約、統合、判断、選択

---

## インフラ構成

### 推奨構成

| コンポーネント       | 推奨サービス                  | 備考                           |
| ------------- | ----------------------- | ---------------------------- |
| MCPサーバー       | Koyeb Free Tier         | コンテナホスティング                   |
| Authサーバー      | Supabase Auth           | JWT発行・検証                     |
| Vault         | Supabase Vault          | トークン暗号化保存                    |
| Edge Function | Supabase Edge Functions | トークン取得・リフレッシュ                |
| オブザーバビリティ     | Grafana Cloud Loki      | ログ収集                         |
| 管理UI          | Verel                   | OAuthクライアントアプリ・シークレットトークンの登録 |

### コスト

全て無料枠で運用可能（$0/月）

| サービス          | 無料枠                  |
| ------------- | -------------------- |
| Koyeb         | 1 Web Service        |
| Supabase      | Auth 50K MAU、Vault含む |
| Grafana Cloud | Loki基本枠              |
| Vercel        | Hobbyプラン無料           |

### コールドスタート対策

CI/CDパイプラインから定期的にヘルスチェックを実行し、サーバーのスリープを回避する。

---

## エンドポイント

| メソッド | パス | 説明 |
|---------|------|------|
| GET | `/health` | ヘルスチェック |
| POST | `/mcp` | MCP Protocol (JSON-RPC 2.0) |

### MCPプロトコル

MCPサーバーはJSON-RPC 2.0 over SSEをサポートする。

| メソッド | 説明 |
|---------|------|
| `initialize` | 接続初期化、サーバー情報返却 |
| `tools/list` | メタツール一覧を返却 |
| `tools/call` | メタツール実行 |

---

## ターゲットユーザー

MCPistは以下のようなパワーユーザーを対象とする：

- 外部サービスのOAuthアプリ登録・トークン管理ができる
- 複数サービスを個別にMCP化する運用負担を避けたい
- LLMはClaude/GPT等の外部サービスを使うが、データの権限は自分で管理したい
- Context Rotがユーザーのエラーではなく構造的問題だと理解している

> **A quiet game changer for people who already know too much.**

---

## 関連ドキュメント

| ドキュメント | 内容 |
|-------------|------|
| ADR-001 | バックエンドLLMを使用しない |
| ADR-002 | シングルテナント・シングルユーザー・マルチアカウント |
| ADR-003 | メタツール + 選択的スキーマ取得パターン |
| ADR-004 | Token Exchangerパターンの採用 |
| MCPist設計哲学 | 設計思想の詳細 |
| ポジション・ステートメント | MCPistの立場表明 |

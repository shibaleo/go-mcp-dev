---
title: MCPist-vendor-lockin-statement
aliases:
  - MCPist-vendor-lockin-statement
tags:
  - technology
document-type:
  - position
document-class: statement
created: 2026-01-13T01:43:06+09:00
updated: 2026-01-13T02:28:37+09:00
---

# MCPist Position Statement: MCPの認証モデルとベンダーロックインリスク

## Executive Summary

Model Context Protocol (MCP) は「AI界のUSB-C」として期待されているが、現在の認証モデルには構造的な問題がある。2025年11月の仕様改定（2025-11-25）により、認証権限がMCPクライアント（Host）およびエンタープライズIdPに集約される設計が明確化された。これにより、ユーザーと企業はLLMベンダーへの依存を深め、将来的な移行が困難になるリスクがある。本文書はこの構造的リスクを分析し、企業に対して導入前の検討を促すものである。

## 問題提起: 誰のためのポータビリティか

### USB-Cの比喩の検証

MCPは「AI界のUSB-C」と称されている。USB-Cの価値は明確だ:

- ユーザーが1本のケーブルでどの機器にも接続できる
- 機器を変えてもケーブルはそのまま使える
- ユーザーがポータビリティの恩恵を受ける

しかしMCPの現実は異なる:

- MCPサーバーは共通化される（ここまではUSB-Cと同じ）
- **認証はMCPホスト（Claude Desktop, Cursor等）およびエンタープライズIdP経由で管理される**
- ホストを変えると、IdP連携を含む認証構成全体を再構築する必要がある

### 恩恵を受けるのは誰か

|観点|USB-C|MCP（現状）|
|---|---|---|
|標準化の恩恵|ユーザー|LLMベンダー|
|ポータビリティ|ユーザーが享受|ベンダーが主張材料に|
|乗り換えコスト|低い|高い（認証再構築）|

LLMベンダーは「MCPサーバーに接続できます」と言える。しかしユーザーは、一度そのベンダーのエコシステムに入ると、移行が困難になる。

## 技術的根拠: 2025-11-25 MCP仕様

### 仕様改定の概要

2025年11月25日、MCPは1周年を迎え、大規模な仕様改定がリリースされた。認証に関する主要な変更は以下の2点である:

1. **Client ID Metadata Documents (CIMD)**: クライアント登録の新しい標準方式
2. **Enterprise-Managed Authorization (Cross App Access / XAA)**: エンタープライズIdPによる認証制御

参照:

- MCP公式仕様: https://modelcontextprotocol.io/specification/2025-11-25/basic/authorization
- MCP公式ブログ: https://blog.modelcontextprotocol.io/posts/2025-11-25-first-mcp-anniversary/
- Aaron Parecki（OAuth 2.1共著者）の解説: https://aaronparecki.com/2025/11/25/1/mcp-authorization-spec-update

### Enterprise-Managed Authorization (XAA) の意味

Aaron Pareckiの解説によると:

> 「これまで、ユーザーがMCPクライアント（AIアプリ）をAsana等のMCPサーバーに接続する際、OAuthはAIアプリとAsanaの間で直接行われていた。しかし、企業のAsanaアカウントがOktaのようなエンタープライズIdPに接続されている場合、Oktaから見えるのは『ユーザーがAsanaにログインした』ことだけであり、ChatGPTとAsanaの間に確立された接続は認識されない。これは今日、エンタープライズにおいてMCPクライアントとサーバー間に膨大な数の『管理されていない接続』が存在することを意味する」

XAAはこの「Shadow IT」問題を解決するために導入された:

> 「Cross App Access (XAA) がEnterprise-Managed Authorization拡張として組み込まれた。ユーザーはMCPクライアントにSSOでサインインし、クライアントはIdPとトークン交換を行い、IdPがポリシーを適用してアサーションを発行する。ユーザーは追加の同意画面を見ることなく、エンタープライズ管理者は完全な可視性と取り消し権限を得る。特定の内部ツールへのAIアクセスを停止したければ、IdPの1箇所で行える」

### 構造的帰結

この設計は企業IT管理者にとっては利点がある。しかし、以下の構造的帰結を生む:

```
認証フローの流れ:
User → MCP Host（SSOログイン）→ Enterprise IdP → Token発行 → MCP Server

管理の集約点:
├── MCP Host: 認証フローを制御
├── Enterprise IdP: トークン発行・ポリシー適用
└── MCP Server: トークン検証のみ
```

**問題点:**

1. **認証管理がHost + IdPに集約**: 認証情報、トークン発行、ポリシー管理がMCPホスト経由のIdP連携に依存
2. **ホスト変更 = IdP連携の再構築**: 別のLLMホストに移行する場合、IdP側の設定（クライアント登録、ポリシー、スコープ等）を再構築する必要がある
3. **「1箇所で管理」の皮肉**: 確かに1箇所で管理できるが、その1箇所がHostに紐づいている

### MCP仕様が定義していないもの

MCPが標準化しているのは:

```
MCPクライアント ←──MCP──→ MCPサーバー
```

MCPが標準化していないのは:

```
LLM ←── ??? ──→ MCPクライアント
```

この「???」の部分が各ベンダー独自実装であり、LLMとMCPクライアントの統合方法はベンダーごとに異なる。結果として:

- MCPサーバーはポータブル（これは良い）
- MCPクライアント〜LLM間はベンダーロックイン（これが問題）
- MCPの「ポータビリティ」は半分だけ実現されている

## 企業への影響: 将来シナリオ

### 典型的な導入パターン

```
2025年: LLMホストAで業務効率化開始
        → 外部サービスコネクタを50個構築
        → エンタープライズIdP（Okta等）との連携設定
        → 社内ワークフローに組み込み

2026年: 業務拡大
        → コネクタ100個に増加
        → IdPポリシーの複雑化
        → 業務のLLM依存度が上昇

2027年: 環境変化
        → LLMホストAが価格改定（例: 月額3倍）
        → または、より優れたLLMホストBが登場
        → または、LLMホストAがサービス方針変更
```

### 移行を試みた場合

```
移行コスト:
├── IdP側のクライアント登録・ポリシー再構築
├── 100個のコネクタの認証再設定
├── 移行期間中の業務中断リスク
├── 従業員の再トレーニング
├── セキュリティ監査の再実施
└── 一部機能の互換性問題対応

結果:
→ 移行コストが継続コストを上回る
→ ロックインされたまま支払い続ける
```

これは、AWSの請求書が高騰しても離れられない企業と同じ構造である。

### リスクの本質

|リスク|説明|
|---|---|
|価格リスク|ベンダーの価格決定権に従うしかない|
|継続性リスク|サービス終了・方針変更に対応できない|
|競争阻害|より良い選択肢があっても移行できない|
|監査リスク|認証フローが第三者（Host）経由になる|
|Shadow ITの逆転|IdPで管理できるが、そのIdP連携がHostに依存|

## 解決の方向性

### 原則: 認証をサーバー側に持つ

```
現状（MCP仕様）:
User → MCP Host（認証管理）→ IdP → MCP Server → 外部API

あるべき姿:
User → MCP Host → MCP Server（認証管理・Token Broker）→ 外部API
```

認証をMCPサーバー側で管理することで:

1. ホストを変えても認証は維持される
2. IdP連携もサーバー側で管理できる
3. LLMの選択が自由になる
4. 真のポータビリティが実現する

### 責任と権限の一致

外部ベンダー依存の場合、**責任と権限の不一致**が生じる:

|項目|責任の所在|権限の所在|
|---|---|---|
|障害時の業務損害|自社|-|
|障害復旧|-|ベンダー|
|SLA設計|-|ベンダー|
|価格決定|-|ベンダー|

自社で認証を管理する場合、**責任と権限が一致**する:

- 障害対応を自社で実施できる
- RTO/RPOを自社要件に合わせて設計できる
- 冗長構成・DR戦略を自分で決められる
- 障害訓練・根本原因分析が可能

**「リスクを外部に出す」ことは「リスクを減らす」ことではない。コントロールできないリスクは、管理できないリスクである。**

### 耐障害性設計: モジュールレジストリとToken Broker

Token Brokerは**論理的な抽象化レイヤー**であり、物理的には複数のVaultに分離できる:

```
Token Broker（論理）
    │
    ├─ GitHub Vault（物理）── GitHub認証情報
    ├─ Notion Vault（物理）── Notion認証情報
    └─ Supabase Vault（物理）── Supabase認証情報
```

各モジュールは独立したVaultにアクセスする:

```
GitHub Module  ──→ Token Broker Interface ──→ GitHub Vault
Notion Module  ──→ Token Broker Interface ──→ Notion Vault
Supabase Module ──→ Token Broker Interface ──→ Supabase Vault
```

**1つのVault障害 → そのモジュールだけ影響。全停止にならない。**

### Vaultのオンライン・オフライン差異の吸収

Token Broker Interfaceは、Vaultの物理構成の差異を吸収する:

```
Token Broker Interface
    │
    ├─ HashiCorp Vault（オンライン・クラウド）
    │    └─ 高可用性、監査ログ、動的シークレット
    │
    ├─ AWS Secrets Manager（オンライン・クラウド）
    │    └─ AWSネイティブ統合、自動ローテーション
    │
    ├─ ローカルファイル暗号化（オフライン）
    │    └─ エアギャップ環境、完全ローカル運用
    │
    └─ 環境変数（開発環境）
         └─ シンプル、即座に利用可能
```

**同一のToken Broker Interfaceを通じて、異なる物理構成を透過的に利用**:

|環境|Vault実装|特徴|
|---|---|---|
|開発|環境変数 / ローカルファイル|セットアップ不要、即座に開始|
|ステージング|HashiCorp Vault（セルフホスト）|本番相当の検証|
|本番（クラウド）|AWS Secrets Manager / HashiCorp Cloud|高可用性、監査、自動ローテーション|
|本番（オンプレ）|HashiCorp Vault（オンプレ）|データ主権、規制対応|
|エアギャップ|ローカル暗号化ファイル|ネットワーク分離環境|

これにより:

1. **開発から本番まで同一コード**: Vault実装を差し替えるだけで環境対応
2. **オフライン運用が可能**: ネットワーク分離環境でもLLM + MCP連携が動作
3. **規制対応**: 金融・医療・政府系のデータローカリゼーション要件に対応
4. **段階的な高度化**: 開発環境から始めて、本番で高度なVaultに移行

### ツールマスク: 認証の完全な隠蔽

MCPist設計では、認証を3つの層に明確に分離する:

```
┌─────────────────────────────────────────────┐
│ Layer 1: ユーザー認証（MCPクライアント）      │
│          「この人は誰か」                    │
│          - JWT / Session / API Key          │
│          - ユーザーの権限レベル確認          │
└─────────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────┐
│ Layer 2: ツールマスク（モジュールレジストリ） │
│          「このユーザーは何が使えるか」       │
│          - ユーザー権限に基づくツールフィルタ │
│          - LLMには許可されたツールだけ見せる │
└─────────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────┐
│ Layer 3: サービス認証（Token Broker）        │
│          「各サービスにどう繋ぐか」          │
│          - OAuth 2.0 / 2.1 / CIMD           │
│          - API Key / Service Account        │
│          - 完全に隠蔽、LLMは知らない        │
└─────────────────────────────────────────────┘
```

MCPクライアント層はユーザー認証（Middleware）のみを担当する。各外部サービスへの認証はToken Brokerで完結し、LLMのコンテキストには一切露出しない。

これにより:

1. **コンテキスト効率**: 認証情報がLLMのコンテキストウィンドウを消費しない
2. **セキュリティ**: 認証方式・トークンがLLMに露出しない
3. **抽象化**: 認証方式（OAuth 2.0 → 2.1、API Key → OAuth等）の変更がLLM側に影響しない
4. **ユーザー体験**: ユーザーもLLMも「ツールを使う」という単純な操作に集中できる

### メタツールによる動的ツール読み込み

MCPist設計では、LLMの初期コンテキストには2つのメタツールのみが存在する:

- `get_module_schema`: モジュールのツール定義を取得
- `call_module_tool`: モジュールのツールを実行

```
従来のMCP設計:
起動時 → 全ツール（100個）をLLMコンテキストに読み込み
       → 使わないツールもコンテキストを消費
       → 権限のないツールも見える（エラーになるだけ）

MCPist設計:
起動時 → メタツール（2個）のみコンテキストに存在
実行時 → LLMがget_module_schemaを呼ぶ
       → ユーザー認証に基づきフィルタリング
       → 権限のあるツールだけ動的に返却
```

LLMが`get_module_schema`を呼び出すと、モジュールレジストリはユーザー認証に基づいてフィルタリングを行い、**そのユーザーが使用権限を持つツールだけ**を返却する。

**コンテキスト効率の比較**:

|項目|従来（全ツール読み込み）|MCPist（メタツール）|
|---|---|---|
|初期コンテキスト|100ツール分|2ツール分|
|権限外ツール|見える（エラー時に判明）|見えない|
|不要ツール|見える|見えない|
|動的追加|不可能|可能|
|LLMの判断精度|低下（選択肢過多）|向上（必要なものだけ）|

**セキュリティ上の意味**:

権限のないツールが見えない = 攻撃対象が見えない

```
従来:
LLM「admin_delete_all_usersというツールがあるな...」
    → プロンプトインジェクションで悪用される可能性

MCPist:
LLM「get_module_schemaで取得したら、read_dataしかない」
    → 権限外のツールは存在すら知らない
```

これにより:

1. **コンテキスト効率**: 100ツールではなく2ツールで開始。必要なものだけ動的に追加
2. **セキュリティ**: 権限のないツールは存在すら見えない。攻撃対象の隠蔽
3. **LLM判断精度**: 選択肢過多による混乱を防止。必要なツールだけで判断
4. **スケーラビリティ**: ツール数が増えても初期コンテキストは一定

**見えないものは使えない** — この原則がMCPist設計の核心である。

### 認証方式の移行: モジュールレジストリ単位での実装

さらに、モジュールレジストリ単位で異なる認証方式を実装できる:

```
モジュールレジストリ A（OAuth 2.0）
    ├─ GitHub Module v1 → GitHub Vault A
    └─ Notion Module v1 → Notion Vault A

モジュールレジストリ B（OAuth 2.1 + CIMD対応）
    ├─ GitHub Module v2 → GitHub Vault B
    └─ Notion Module v2 → Notion Vault B
```

これにより、**サービス停止なしで段階的に移行**できる:

```
Phase 1: レジストリAで運用中
Phase 2: レジストリBを並行稼働（新認証方式対応）
Phase 3: トラフィックを徐々にBへ移行
Phase 4: 問題なければレジストリAを退役、問題あればロールバック
```

### MCP仕様のIdP依存との比較

|観点|MCP仕様（IdP経由）|提案（モジュールレジストリ）|
|---|---|---|
|障害分離|IdP障害 = 全停止|Vault/モジュール/レジストリ単位で分離|
|認証方式の移行|Host + IdPの対応待ち|自分でレジストリを追加して移行|
|並行運用|不可能|可能|
|ロールバック|不可能|可能|
|段階的移行|不可能|可能|
|耐障害性評価|不可能（ベンダー依存）|可能（自社設計）|
|オフライン運用|不可能（IdP接続必須）|可能（ローカルVault）|
|エアギャップ対応|不可能|可能|
|規制対応（データローカリゼーション）|困難|容易|

### 完全なポータビリティの実現

```
┌─────────────────────────────────────┐
│  ユーザー/企業管理のMCPエコシステム  │
│  ┌─────────┐    ┌────────────────┐  │
│  │ 軽量UI  │    │ MCPクライアント │  │
│  └────┬────┘    └───────┬────────┘  │
│       │                 │           │
│       ▼                 ▼           │
│  ┌──────────────────────────────┐   │
│  │ LLM選択（自由に切り替え可能） │   │
│  │ ・Claude API                 │   │
│  │ ・GPT API                    │   │
│  │ ・Gemini API                 │   │
│  │ ・Ollama（ローカル/オフライン）│   │
│  └──────────────────────────────┘   │
└─────────────────────────────────────┘
            │
            ▼
     MCPサーバー + モジュールレジストリ
            │
            ▼
     Token Broker（論理）
       ├─ Vault A
       ├─ Vault B
       └─ Vault C
            │
            ▼
        外部API
```

### エンタープライズにとっての利点

|観点|現状（Host側認証）|提案（Server側認証）|
|---|---|---|
|LLM選択|ホストに縛られる|自由に選択可能|
|移行コスト|高い|低い|
|オフライン運用|不可|可能（Ollama等）|
|機密データ|外部経由|ローカル完結可能|
|監査|Host依存|自社管理|
|価格交渉力|弱い|強い|
|耐障害性評価|不可能（ベンダー依存）|可能（自社設計）|
|障害対応権限|なし（待つだけ）|あり（自分で対応）|
|責任と権限|不一致|一致|
|認証方式の移行|Host対応待ち|段階的に自社で実施|
|ロールバック|不可能|可能|

## 企業への推奨事項

### 導入前の検討

1. **認証フローを把握する**: どのコンポーネントが認証を制御し、IdP連携がどこに依存するか
2. **移行コストを見積もる**: ホスト変更時のIdP再設定、コネクタ再認証のコストを事前に把握
3. **契約条件を精査する**: 価格改定条項、データポータビリティ条項、サービス終了時の対応を確認

### リスク軽減策

1. **コネクタ数を意識する**: 依存度の指標としてコネクタ数とIdPポリシー複雑度を管理
2. **代替手段を維持する**: 重要な機能は複数の実現手段を確保
3. **サーバー側認証を検討する**: 認証をMCPサーバー側で管理する構成を評価
4. **ローカルLLMオプションを検討する**: 機密性の高い業務はOllama等のローカルLLMで運用

## 結論

MCPは素晴らしい標準化の試みであり、AI-ツール連携の未来を切り開くものである。2025-11-25仕様でEnterprise-Managed Authorization (XAA) が導入されたことで、エンタープライズIdPとの連携が標準化され、Shadow IT問題への対応が進んだ。

しかし、この設計には構造的な問題がある。「IdPで1箇所管理」は確かに実現されるが、そのIdP連携自体がMCPホストに紐づいている。ホストを変えれば、IdP側の設定も再構築が必要になる。

「AI界のUSB-C」という比喩は、ベンダーにとっては正しい。彼らは「MCPに対応しています」「エンタープライズIdP連携できます」と言えるようになった。しかしユーザーと企業にとって、真のポータビリティは実現されていない。

LLMベンダーでない企業が、自社のMCPエコシステムを自社で管理し、LLMを自由に選択するという健全なパターンは、現在の仕様では阻害されている。企業は、MCPエコシステムへの投資が将来のベンダーロックインにつながるリスクを理解した上で、導入を判断すべきである。

---

_本文書は特定のベンダーを批判するものではなく、MCP仕様の構造的分析に基づくリスク提起である。_

## 参照リンク

- MCP公式仕様 (2025-11-25 Authorization): https://modelcontextprotocol.io/specification/2025-11-25/basic/authorization
- MCP公式ブログ - 1周年リリース: https://blog.modelcontextprotocol.io/posts/2025-11-25-first-mcp-anniversary/
- Aaron Parecki - MCP Authorization Spec Update: https://aaronparecki.com/2025/11/25/1/mcp-authorization-spec-update
- WorkOS - MCP 2025-11-25 Spec Update: https://workos.com/blog/mcp-2025-11-25-spec-update
- Den Delimarsky - November Authorization Spec: https://den.dev/blog/mcp-november-authorization-spec/

---

_Document Version: 1.3_ _Date: 2026-01-13_ _Author: MCPist Project_ _Changes: v1.1 - Added fault tolerance design, responsibility-authority alignment, and module registry architecture. v1.2 - Added online/offline Vault abstraction and air-gap environment support. v1.3 - Added tool masking, meta-tool dynamic loading, and security implications._